[TOC]

# （一）简答题

### 1 为什么需要商务智能？

* 许多数据仓库解决方案的共同缺点就是系统的开发者专注于软件技术，而不是商业解决方案
* 数据仓库产品实施起来复杂
* 数据仓库产品很少针对特定产业、应用领域提供解决方案
* 企业需要的是商务解决方案，而不是技术本身
* 人们过多关系如何建立数据仓库，而不是如何进行访问
* 许多企业认为他们只需要建立起数据仓库并为用户提供合适的工具。其实这只是个开始

### 2 什么是操作型处理

* 也叫事务处理，是指对数据库的日常联机访问操作，通常是对一个或一组记录的查询和修改，主要是为企业特定的应用服务的，所以也叫联机事务处理
* OLTP online transaction processing
	* 通常仅仅是是对一个或一组记录的查询或修改
	* 查询简单，但==执行频率高==
	* 人们关心的是处理的==响应时间==、数据安全性和完整性等指标

### 3 什么是分析型处理

* 也叫信息型处理，主要用于企业管理人员的==决策分析==，为制定企业的未来经营管理计划提供辅助决策信息
	* 需要对大量的事务型数据进行==统计、归纳和分析==
	* 需要访问==大量历史数据==
	* ==执行频率和对响应时间==的要求不高
* 典型的分析型处理
	* DSS decision support system 决策支持系统

### 4 为什么在传统的以数据库为核心的事务环境中不适宜建立DSS？

1. **事务处理和分析处理的特性功能不同**
	* 用户每次操作处理的时间段，存取数据量小，但操作频率高，并发程度大
	* 每次分析可能需要连续运行很长的时间，存取数据量大，但很少做这样的分析处理，也没有并发执行的要求
2. **数据集成问题**
	* 事务处理==一般只需要与本业务部门有关==的当前细节数据
	* 分析处理的数据可能来自==多种不同的数据源==
	* 对于需要集成数据的DSS应用来说，在应用程序中对事务处理环境中的这些纷繁复杂的数据进行集成，将带来下述问题：     
		- 大大加重程序员的负担
		- 重复计算
		- 极低的分析处理效率
3. **数据的动态集成问题**
	* 集成数据必须以==一定的周期进行刷新（即采用动态集成策略）==，**但传统的事务处理并不具备动态集成的能力**
4. **历史数据问题**
	* 事务处理一般只需要==当前数据（3~6个月）==
	* 分析处理更看重==历史数据（5~10年）==
5. **数据的综合问题**
	* 事务处理需要的是当前的==细节性操作数据==
	* 分析处理需要的往往是大量的==总结性分析型数据==，而非数据库中的细节性操作型数据（数 据丰富、信息贫乏）
	* 在分析前往往需要==对细节数据进行不同程度的综合==，传统的事务处理不具备这种综合能力
6. **数据的访问问题**
- 事务处理对于需要修改的数据必须==实时“更新”数据库==
	- 分析处理==以“读”操作为主==，不需要实时的“更新”操作，但==需要定时刷新==

### 5 ETL是什么？在数据仓库架构中ETL完成什么任务？

**ETL**（extract translation load）数据提取、转换、装载

数据仓库中的数据来源于数据源，将数据源中数据通过网络进行抽取，并经加工、转换、综合后形成数据仓库中的数据，这就 是数据仓库的数据抽取。

* 识别与主题相关的原始数据
* 开发数据抽取策略
* 将原始数据转换为目标规格
* 将原始数据加载到预定目标区域

### 6 什么是数据仓库，四大特色？

数据仓库就是一个==面向主题的、集成的、不可更新的、随时间不断变化==的==数据集合==，用于==支持==经营管理过程中的==决策制定==

* **面向主题**
	* 主题是较高层次上将企业信息系统中的数据综合、归类并进行分析利用的抽象。在逻辑意义上，是对企业中某一宏观分析领域涉及的分析对象
	* **面向主题是指数据仓库内的信息是按主题进行组织的，为按主题进行决策的过程提供信息**
* **集成**
	* 数据仓库中的数据是为分析服务的，而分析需要多种广泛的不同数据源以便进行比较、鉴别，因此**数据仓库中的数据必须从多个数据源中获取**
* **非易失/稳定的**
	* 执行的==主要是查询操作==，一般情况下不执行“更新”操作
* **随时间不断变化**
	* 数据仓库中的数据通常带有==时间属性==，同时必须==以一定时间段为单位进行统一更新==
	* 比如，不断增加新的数据内容、删去旧的数据内容、更新与时间有关的综合数据

### 7 什么是数据刷新？简述数据仓库刷新的方法，并对每种方法进行简单的说明

经过抽取进入数据仓库的数据，在经过一段时间后要==重新修正，修改那些过时的数据，保存那些不变的数据==，此种动作被称为数据仓库的刷新

1. **时间戳**
	* 适用情况：数据库中的记录有==时间属性==，可以==根据OTLP数据库中的数据有无更新==，以及在更新操作时数据的==修改时间标志==来实现数据仓库数据的动态刷新
	* 缺点：大多数数据库的数据不包含时间属性
2. **DELTA文件**
	* 适用情况：有些OLTP数据库的应用程序在工作过程中会形成一些DELTA文件以==记录该应用所作的数据修改操作==，可根据该DELTA文件进行数据刷新
	* 优点：采用此方法可避免对整个数据库的对比扫描，具有较高的刷新效率
	* 缺点：这样的应用程序并不普遍，修改现有的应用程序的工作量又太大
3. **映像文件**
	* 实现方法：在上一次数据刷新后对数据库作一次==快照==，在本次刷新之前再对数据库作一次快照。比较两个快照的不同，从而确定数据仓库的数据刷新操作
	* 缺点：需要占用大量的系统资源，可能较大地影响原有数据库系统的性能
4. **日志文件**
	* 实现方法：一般OLTP数据库都有日志文件，可==根据OLTP数据库的日志信息==来实现数据仓库的数据刷新
	* 优点：日志是OLTP数据库的固有机制，不会影响原有OLTP数据库的性能，具有比DELTA文件和建立映像文件更高的刷新效率

### 8 什么是数据仓库中的粒度？为何要采用多重粒度？

* 粒度是对数据仓库中数据的综合程度的一个度量，既影响数据仓库中==数据量的多少==，也影响数据仓库==能够回答询问的种类==。
* 粒度越小，细节程度越高，综合程度越低，回答查询种类越多，查询效率越低
* **多重粒度**能够应对不同级别的粒度要求
	* 大粒度数据放在快速存储设备中，以提升性能
	* 小粒度数据放在低速存储设备中，以满足细节查询

### 9 什么是元数据？元数据有什么用？

* 关于数据的数据，描述了数据的==结构、内容、编码、索引等==内容
* 通过元数据可以==将数据仓库和复杂的数据源系统的变化隔离==，是==数据仓库开发和维护==的一个关键因素，也是保证==数据抽取质量==的依据
	* 关于数据源的元数据（数据源有哪些，物理数据结构、业务定义）
	* 关于数据模型的元数据（数据仓库有什么数据、数据之间的关系）
	* 与数据仓库映射相关的元数据（数据源到数据仓库的转换规则）
	* 关于数据仓库使用的元数据

### 10 为何数据仓库中还需要建立数据集市？在企业中建立数据仓库和数据集市的方法主要是哪四种？分别描述，并总结优缺点

* 早期的数据仓库概念仅仅提供了一个多源数据库的数据集成功能，为最终用户访问多个数据源提供统一的数据视图和访问接口
* 然而，==全局数据仓库太大==，在实际应用中，将他们==按照部门或者个人==建立==反映各个子主题与区域==的==局部性数据组织==，即是**数据集市**，也称为部门数据仓库

主要方法有：

* **自顶向下的结构**
	* 构建企业数据仓库 → 基于企业数据仓库构建数据集市
	* 优点：
		* 建立数据集市，减轻DW访问负载
		* 各部门可以任意处理数据
		* 数据转换和整合在DW阶段统一完成
		* 具备数据缓冲功能
	* 缺点：
		* 成本高、见效慢、数据集市间数据不可共享
* **自底向上的结构**
	* 构建数据集市 → 基于数据集市构建企业数据仓库
	* 优点：
		* 见效快、启动资金少
	* 缺点：
		* 各个部门都要进行数据清洗
		* 可能造成“蜘蛛网”、数据不一致
		* 总体上没有节约资金
* **总线结构的数据集市**
	* ==不建立数据仓库而是直接建立数据集市==，各个数据集市之前不是相互独立的，而是通过==共享维表和事实表的总线结构==紧密联系
	* 优点：
		* 共享维表和事实表，解决了建立数据仓库的许多问题
	* 缺点：
		* 基于多维模型，应用限制于OLAP
		* 多个数据源直接影响多个集市，造成数据仓库结构不稳定
* **企业级数据集市结构（PPT上没）**
	* 在没有数据仓库的前提下用总线结构构建数据集市
	* 数据集市遵循总线结构进行独⽴开发部署 
	* ETL过程不存在数据结构问题

### 11 数据仓库的物理模型设计优化技术有哪些？对这些技术做简要说明

在逻辑模型设计基础上确定数据的存储结构、确定索引策略、确定存储分配及数据存放位置等与物理有关的内容，物理模型设计的具体方法与数据库设计中的大致相似。其目的是为了提高数据仓库系统的访问性能。常用的一些技术有：

1. **合并表**
	* 减少表连接操作
2. **建立数据序列**
	* 考虑创建一个数据序列，这样如果数据存放在一行中，那么一次 I/O 就足以检索到了
3. **引入冗余**
	* 减少一次分析过程需要访问的表的数量
4. **表的物理分割** 
	* 对于访问频率较高的属性，可以单独考虑其物理存储组织，以便选择合适的索引策略和特定的物理组织方式。 
	* 对于需要频繁更新的属性，也可以单独组织其物理存储，以免因数据更新而带来的空间重组、重构等工作
5. **生成导出数据**
	*  在原始、细节数据的基础上进行一些统计和计算，生成导出数据，并保存在数据仓库中
6. **建立广义索引**
	* 用于记录数据仓库中数据与“最”有关的数据统计结果的索引被称为广义索引，如月销售额最差的店...
	* 这样的广义索引的数据量是非常小的，可以在每次进行数据仓库数据加载工作时生成或刷新这样的广义索引。用户可以从已经建立的 广义索引里直接获取这些统计信息，而不必对整个数据仓库进行扫描

### 12 什么是杂项维度，怎样处理？

* 从复杂的数据源中提取与事实、维度相关的字段后，往往还有大量在小范围内选取的离散值的指示符与标志
	* 如果保存在事实表，会造成事实表膨胀
	* 如果放在单独的维度中，会造成维度膨胀
	* 删除？
* 因此，也可以组装成一个或多个独立的==杂项维度表==
	* 预先为所有组合创造维度行
	* 实际遇到后，马上创建行

### 13 什么是数据仓库中的历史完整性/一致性？为保持历史完整性/一致性，可以采用哪些方式，举例说明

> 可能会出一道大题，详见综合题2

* 历史完整性：部分维度属性是会随时间而发生变化的，若只是将这些变化的维度属性值作简单的修正，即在维度表中只保留该维度属性的当前值，这会直接影响到对事实 表中该维度属性所对应的事实数据元组的访问，特别是无法根据维度属性值的变化情况来进行分析处理。**保证维度中的历史数据在改变之后不丢失。**
	
* （AKA 引用完整性，参考https://blog.csdn.net/keminlau/article/details/389028）
	
* 解决Type1：改写属性值

	| Supplier_Key | Supplier_Code | Supplier_Name  | Supplier_State |
	| :----------: | :-----------: | :------------: | :------------: |
	|     123      |      ABC      | Acme Supply Co |       CA       |

	改写为

	| Supplier_Key | Supplier_Code | Supplier_Name  | Supplier_State |
	| :----------: | :-----------: | :------------: | :------------: |
	|     123      |      ABC      | Acme Supply Co |       IL       |

* 解决Type2：添加维度行

	| Supplier_Key | Supplier_Code | Supplier_Name  | Supplier_State | Version |
	| :----------: | :-----------: | :------------: | :------------: | :-----: |
	|     123      |      ABC      | Acme Supply Co |       CA       |    0    |
	|     124      |      ABC      | Acme Supply Co |       IL       |    1    |

* 解决Type3：添加维度列

	| Supplier_Key | Supplier_Code | Supplier_Name  | Original_Supplier_State |   Effective_Date    | Current_Supplier_State |
	| :----------: | :-----------: | :------------: | :---------------------: | :-----------------: | :--------------------: |
	|     123      |      ABC      | Acme Supply Co |           CA            | 2004-12-22T00:00:00 |           IL           |

* 解决Type6：综合123

	The Supplier table starts out with one record for our example supplier:

	| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name  | Current_State | Historical_State |     Start_Date      |      End_Date       | Current_Flag |
	| :----------: | :-----: | :-----------: | :------------: | :-----------: | :--------------: | :-----------------: | :-----------------: | :----------: |
	|     123      |    1    |      ABC      | Acme Supply Co |      CA       |        CA        | 2000-01-01T00:00:00 | 9999-12-31T23:59:59 |      Y       |

	The Current_State and the Historical_State are the same. The optional Current_Flag attribute indicates that this is the current or most recent record for this supplier.

	When Acme Supply Company moves to Illinois, we add a new record, as in Type 2 processing, however a row key is included to ensure we have a unique key for each row:

	| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name  | Current_State | Historical_State |     Start_Date      |      End_Date       | Current_Flag |
	| :----------: | :-----: | :-----------: | :------------: | :-----------: | :--------------: | :-----------------: | :-----------------: | :----------: |
	|     123      |    1    |      ABC      | Acme Supply Co |      IL       |        CA        | 2000-01-01T00:00:00 | 2004-12-22T00:00:00 |      N       |
	|     123      |    2    |      ABC      | Acme Supply Co |      IL       |        IL        | 2004-12-22T00:00:00 | 9999-12-31T23:59:59 |      Y       |

	We overwrite the Current_State information in the first record (Row_Key = 1) with the new information, as in Type 1 processing. We create a new record to track the changes, as in Type 2 processing. And we store the history in a second State column (Historical_State), which incorporates Type 3 processing.

	For example, if the supplier were to relocate again, we would add another record to the Supplier dimension, and we would overwrite the contents of the Current_State column:

	| Supplier_Key | Row_Key | Supplier_Code | Supplier_Name  | Current_State | Historical_State |     Start_Date      |      End_Date       | Current_Flag |
	| :----------: | :-----: | :-----------: | :------------: | :-----------: | :--------------: | :-----------------: | :-----------------: | :----------: |
	|     123      |    1    |      ABC      | Acme Supply Co |      NY       |        CA        | 2000-01-01T00:00:00 | 2004-12-22T00:00:00 |      N       |
	|     123      |    2    |      ABC      | Acme Supply Co |      NY       |        IL        | 2004-12-22T00:00:00 | 2008-02-04T00:00:00 |      N       |
	|     123      |    3    |      ABC      | Acme Supply Co |      NY       |        NY        | 2008-02-04T00:00:00 | 9999-12-31T23:59:59 |      Y       |

参考：https://en.wikipedia.org/wiki/Slowly_changing_dimension

### 14 数据仓库的设计原则？

数据仓库是面向主题的、集成的、非易失的、时变的

1. **面向主题原则**

	构建数据仓库的目的是为了支持面向主题的决策，从用户的主观需求（主题）出发

	数据仓库的组织方式是依据主题划分的

2. **数据驱动原则**

	数据仓库中的数据必须是从已有的数据源中抽取出来

3. **原型法原则**

	数据仓库的原始需求不明确，且不断变化与增加，是一个逐步求精的过程

### 15 数据仓库的设计步骤

1. 系统规划

	* 明确主题
	* 技术准备

2. 概念设计

	* 确定系统边界
	* 确定主要的主题及其内容（分析对象、每个属性的取值情况等）
	* OLAP等分析应用设计
	* ER图

3. 逻辑设计

	* ER图 → 数据库中的二维表
	* 定义数据源和数据抽取规则

4. 物理设计

5. 数据仓库生成

6. 数据仓库的运行与维护

### 16 原子层是什么，有哪些特点

原子层是数据仓库的基础，上层分析应用的数据来源，所有战略分析型数据的基础

* 原子层保持历史集成性
* ...拥有最低粒度数据
* ...构建是迭代的
* ...数据结构是面向企业的
* ...可以是集成的
* ...可以是动态的

# （二）综合题

### 1 OLAP

> 1）请给出一个具体的数据立方体模型的例子。（绘图说明）
>
> 2）以该数据立方体为例介绍OLAP中的维和层的概念。
>
> 3）以该数据立方体中的某一维为例，举例说明什么是切片（slice）、切块（dice）、数据概括（roll-up）和数据细化（drill-down）操作。

1. 预先计算好数据视图中的统计信息并保存在数据仓库中，这称为 “物化视图”，即将虚的视图转变成实际的视图，==存放物化视图的三维数据模型叫“数据立方体“==

	<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/{A80B094A-D8CB-4914-2333-F7147A29BB8A}.png" alt="img" style="zoom: 33%;" />

2. **维**：观察度量值的维度

	* 例如，可以从三个维观察销售金额这个度量值
		* 时间维：不同时间段
		* 地域维：根据每个连锁店所在的地域统计
		* 商品维：每一类商品

	**层**：反映了对度量值的观察深度

	* 同一个维度可以存在若干层，并且可以采用不同“层”次划分方法
		* 时间维：日月季年、日周年
		* 地域维：市省国洲

	例如，日期、商品、地区是三个维度，日期维的层次是季度

3. 切片：Date=1Qrt

	切块：(Date=1Qrt or 2Qrt) and (Product=PC or TV) and (Store=USA or CHINA)

	旋转：(Date x Product) → (Product x Date)

	上钻：把地区维度的层次，市合为省份

	下钻：把Date展开为一月、二月、...

### 2 历史一致性？

![image-20210112212916351](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210112212916351.png)

参考https://en.wikipedia.org/wiki/Slowly_changing_dimension