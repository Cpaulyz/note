# 1 小组成员

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

# 2 实验目的

实现一个有回路的拓扑，验证RIP协议能够有效阻止路由回路。

# 3 实验步骤

## 3.1 实验设备

PC：两台；

Router：三台；

交叉线；

直连线；

## 3.2 实验拓扑

![1589204774402](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223157935-441707944.png)

## 3.3 IP地址规划

| 设备名称 | 端口                          | 地址                          |
| -------- | ----------------------------- | ----------------------------- |
| PC0      | FastEthernet                  | 192.168.10.2                  |
| PC1      | FastEthernet                  | 192.168.40.2                  |
| 路由器1  | FastEthernet0/0<br>Serial2/0  | 192.168.10.1<br>192.168.20.1  |
| 路由器2  | Serial2/0<br>Serial3/0        | 192.168.20.2<br>192.168.30.1  |
| 路由器3  | Serial3/0<br/>FastEthernet0/0 | 192.168.30.2<br/>172.168.40.1 |

## 3.4 拓扑准备

1. 如图连接拓扑

2. 分别为PC0、PC1配置IP地址

3. 打开路由器1的FastEthernet0/0端口，设置IP地址为192.168.10.1；并将Serial2/0端口打开，设置Clock Rate 64000, IP Address:192.168.20.1；

	打开路由器2的Serial2/0、3/0端口，设置Clock Rate 64000, IP Address分别为192.168.20.2、192.168.30.1；

	打开路由器3FastEthernet0/0端口，设置IP地址为192.168.40.1；并将Serial3/0端口打开，设置Clock Rate 64000, IP Address:192.168.30.2

	```
	以R1为例：
	R1(config)#interface FastEthernet0/0
	R1(config-if)#ip address 192.168.10.1 255.255.255.0
	R1(config-if)#interface Serial 2/0
	R1(config-if)#ip address 192.168.20.1 255.255.255.0
	R1(config-if)#clock rate 64000
	R1(config-if)#no shutdown
	```

4. 为PC配置默认网关，以PC0为例

	![1589205051835](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223157644-745054668.png)

5. R1、R2、R3打开rip，以R3为例

	```
	Router(config)#router rip
	Router(config-router)#network 192.168.40.0
	Router(config-router)#network 192.168.30.0
	```

6. 在R3中开启debug模式，并查看路由表

	```
	Router#debug ip rip
	```

	![1589205282293](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223157358-490486906.png)

	```
	Router#show ip route
	```

	![1589205320685](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223157006-692668705.png)

	发现此时路由器配置无误

7. PC0 ping PC1，说明拓扑无误

	![1589205421571](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223156674-1848874516.png)

## 3.5 构造路由回路

1. 为了构造路由回路，我们需要先关闭R2和R3之间的水平分割

	```
	R3(config)#in s3/0
	R3(config-if)#no ip split-horizon
	R2(config)#in s3/0
	R2(config-if)#no ip split-horizon
	```

2. 将PC1和R3间的链路断开

	![1589206152339](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223156418-1270841524.png)

3. 在debug模式下观察R2、R3的rip及路由表

	**R2**![1589206246485](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223156083-1228194965.png)

	**R3**

	![1589206313310](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223155755-1691486181.png)

	可以看出 

	| 路由器 | 目的网段     | 下一条路由器 |
	| ------ | ------------ | ------------ |
	| R2     | 192.168.40.0 | R3           |
	| R3     | 192.168.40.0 | R2           |

	这就形成了路由回路

4. 进入模拟模式，PC0上ping 192.168.40.2（ping 192.168.40.1结果也一样）

	![1589206392934](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223155405-2011468991.png)

	可以看到ICMP包在R2、R3间不断传递，进入死循环，这就造成了路由回路，故超时

	![1589207249434](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223155131-810062688.png)

## 3.6 RIP协议避免路由回路

1. 恢复链路，并开启R2、R3间的水平分割

	```
	R2(config)#in s3/0
	R2(config-if)#ip split-horizon 
	R3(config)#in s3/0
	R3(config-if)#ip split-horizon 
	```

2. 断开PC1与R3间的链路

3. 在debug模式下观察R2、R3的rip及路由表

	R3

	![1589206862275](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223154855-1659627344.png)

	R2

	![1589206997901](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223154540-1048447547.png)

	可以看到，开启水平分割后R3不会从R2收到关于192.168.40.0的信息，R2也不会向R3发送192.168.40.0的信息

4. 180s后，查看R2的路由表

	![1589207057384](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223154164-1408680380.png)

	192.168.40.0已经为down状态

5. 在PC0上ping 192.168.40.2（ping 192.168.40.1结果也一样）

	![1589207111383](https://img2020.cnblogs.com/blog/1958143/202005/1958143-20200511223153675-676524443.png)