
# DV问题

## 路由振荡

举个例子 

**路由器 A---B**

| 发生的事情                                                   | A中到目的N | B中到目的N |
| ------------------------------------------------------------ | ---------- | ---------- |
| A给B更新，N可达                                              | 可达       | 可达       |
| A收到N不可达的RIP报文，给B更新。由于A-B上的时延，B也给A更新。 | 可达       | 不可达     |
| 过了一段时间，A告诉B可达，B告诉A不可达                       | 不可达     | 可达       |
| ...                                                          | ....       | ...        |

就会一直往复下去。

## 路由回路

![1587889802534](https://img2020.cnblogs.com/blog/1958143/202004/1958143-20200429120534450-631537791.png)

假如有这么一个拓扑，10.4.0.0接口断开，从C的路由表中消失。

这时候C还更新周期还没到，B的更新周期到了，B给A和C发送RIP报文，C进行了更新。

![1587889868713](https://img2020.cnblogs.com/blog/1958143/202004/1958143-20200429120533906-1765301592.png)

之后，C给B发送RIP报文，进行更新，于是B、C的路由表就会变成这样

| 路由器 | 到目的10.4.0.0d的下一条路由器 |
| ------ | ----------------------------- |
| B      | C                             |
| C      | B                             |

于是就产生了路由环路。

## 跳数无限大

在上面这个例子，就会发生跳数会一直增大，变成无限（假设不加以限定的话）

# DV规则

## 设定最大跳数

设定最大跳数为15，16就是不可达

## 水平分割split horizons

**概念**：由于路由器可能收到它自己发送的路由信息，而这种信息是无用的。

**原理**：路由器从某个接口接收到的更新信息不允许再从这个接口发回去。

**优点**

1. 能够阻止路由环路的产生。

2. 减少路由器更新信息占用的链路带宽资源。

**思想**
	就是在路由信息传送过程中，不再把路由信息发送到接收到此路由信息的接口上。从而在一定程度上避免了环路的产生。

## 路由毒化Route Poisoning

![1587890866825](https://img2020.cnblogs.com/blog/1958143/202004/1958143-20200429120533358-1635964611.png)

还是这个例子，10.4.0.0网络从C断开后，C不是直接删除条目。而是

1. C发现与10.4.0.0连接发生故障
2. C将自己关于10.4.0.0的路由信息**毒化**，更新设置距离向量中的距离为16
3. C把毒化后的信息发送给邻接路由器B，意义就是”这个网段怎么走我现在无可奉告了“，**B会对收到的信息与自身路由表进行比对，如果路由表下一条是C**（解释1），B也会把10.4.0.0的网段的路由信息**毒化**。
4. 于是最多只要两个周期，就能完成收敛。

> **解释1**：为了避免这样一种情况，拓扑结构发生了改变，10.4.0.0网段从C断开，接入了B，这时候B已经更新了路由表，设10.4.0.0可达，但下一条不是C，这时候到10.4.0.0网段已经和C没关系了，所以不可以被毒化。

## 毒性逆转Poisoned Reverse

有了路由毒化，可能还会有一些问题。比如我们又产生了路由震荡中的时延问题，可能BC的状态会变成这样

| 路由器 | 到目的10.4.0.0d的下一条路由器 | 距离 |
| ------ | ----------------------------- | ---- |
| B      | C                             | 16   |
| C      | B                             | 2    |

这明显是有问题的，所以需要配合毒性逆转。

**毒性逆转实际上是一种改进的水平分割。**

这种方法的**运作原理**是：路由器从某个接口上接收到某个网段的路由信息之后，并不是不往回发送信息了，而是发送，只不过是将这个网段的**跳数设为无限大**，再发送出去。

抽象来说，就是如果Z的最短路径要通过邻居Y，那么它将告诉Y自己到目的节点的距离是∞。这样，Z向Y撒了一个善意的谎言，使得只要Z经过Y选路到X，它就会一直持续讲述这个谎言，这样Y也就永远不会尝试从Z选路到X了，也就避免了环路问题。



# RIP规则

**RIP是一种分布式的基于距离向量的路由选择协议**

1. 对地址为X的路由器发来的RIP报文，先进行修改，把下一条地址都改为X，把距离都+1。每一个项目都三个关键数据：**目的网络N、距离d、下一条路由器X**
2. 对修改后的RIP报文的每一个项目，进行以下步骤：
	- 若原路由表没有目的网络N，直接写进去
	- 否则（即原本就有到目的网络N的条目了）
		- 若下一条路由器地址为X，则进行替换*（解释1）*
		- 否则（有到目的网络N，但下一条不是X）
			- 若d<路由表中的距离，进行更新*（解释2）*
			- 否则什么也不做*（解释3）*
3. 若3分组还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，距离设为16
4. 返回

> **解释1**：因为这是最新的消息，到目的网络的距离可能增大或减小，比如拓扑发生了改变？。不过不管怎么样，X的消息总是最新的，听他的就是了
>
> **解释2**：DV以跳数作为评判，距离小了当然要更新。
>
> **解释3**：没有好处，不更新。

举个例子

![1587889458630](https://img2020.cnblogs.com/blog/1958143/202004/1958143-20200429120532890-456431435.png)

![1587889483193](https://img2020.cnblogs.com/blog/1958143/202004/1958143-20200429120532395-1855552901.png)

# RIP计时器

## 更新计时器

用于实现对路由条目的周期交互（是否有数据流量），默认是30秒更新一次路由表中的信息。

## 失效计时器

如果某一条路由信息在180s内没有收到更新或确认，那么这条路由信息将被标记为“失效”。

如果路由器30s还未收到邻居发过来的路由更新包，则更新计时器超时。如果再过150s，达到180s（即30s + 150s = 180s）还没收到路由更新包，说明失效计时器超时了，然后路由器将邻居路由器的相应路由条目标记为is possibly down，此时并不是真正失效了，是提示快要失效了。

## 抑制计时器

失效计时器到时，立马进入180s的抑制计时器，用于防止路由环路。  

如果在抑制期间从任何相邻路由器接收到少量的路由更新包，则恢复该网络并删除抑制计时器。

如果在抑制期间从相邻路由器收到的一条路由更新的跳数大于路由表已记录的跳数，则该更新将被忽略。

## 刷新计时器

`失效计时器到时，再过60s`，达到240s的刷新计时器（180s + 60s = 240s），还没收到路由更新包。路由器就刷新路由表，把不可达的路由条目删掉。 