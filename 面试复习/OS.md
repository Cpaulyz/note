# OS

## 谈谈你对OS的理解

从OS发展的角度来看

* 一开始的计算机是没有操作系统的，是手工操作阶段，手工设置操作位，用户独占资源，数据输入、程序执行、结果输出均联机进行，效率低。
* 引入了装入程序，用卡片和纸带来描述，装入→汇编/编译→执行→输出。脱机执行，例如shell脚本
* 再后来出现了批处理，操作员成批输入作业，成批执行作业
* 由于IO和计算速度的差异，引入了多道程序
* 磁盘出现，OS登场

从OS的作用来看

* 计算机系统最基础的系统软件，管理软硬件资源、控制程序执行，改善人机界面
* 包括了进程调度、进程通信、内存管理、设备管理、文件管理、作业控制等

## 有哪些寄存器？

* 用户可见寄存器
	* 数据寄存器（通用寄存器）
	* 地址寄存器（索引、栈地址、段地址等）
		* 页表基址寄存器：只有一个，哪个进程在运行，存的就是哪个
* 控制与状态寄存器
	* 控制寄存器
	* 程序计数器PC
	* 指令寄存器IR
	* 条件码CC
	* 标志位（中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位...）
* 程序状态字PSW 指记录**当前程序运行的动态信息**，通常包含： 
	* 程序计数器，指令寄存器，条件码 
	* 中断字，中断允许/禁止，中断屏蔽，处理器模式，内存保护、调试控制
	* 可以设置一组控制与状态寄存器、也可专设一个PSW寄存器
	* 例如，x86中，PSW由标志寄存器EFLAGS和指令指针寄存器EIP组成

## 管态和目态？

CPU有两个状态，分别是管态和目态，

* 管态，即操作系统的管理程序运行时的状态，具有较高的特权级别，也称为特权态、系统态、内核态或者核心态。当处理器处于管态时，可以执行所有的指令，包括各种特权指令，也可以使用所有的资源，并且具有改变处理器状态的能力。
* 目态，即用户程序运行时的状态，具有较低的特权级别，又称为普通态或用户态。在这种状态下不能使用特权指令，不能直接使用系统资源，也不能改变CPU的工作状态，并且只能访问这个用户程序自己的存储空间。
* 特权指令：仅在内核态下才能使用的指令，设计改变机器状态、修改寄存器内容、启动设备IO等
	* 如启动IO设备、设置时钟、清空内存、建立存储键、设置中断屏蔽位、修改寄存器值、加载PSW等
* 非特权指令
	* 能被所有程序使用

## 什么是系统调用？实现机制是怎样的？

1. 编写系统调用服务例程
2. 设计系统调用入口地址表（可能还包含参数个数）
3. 陷阱处理机制，需要开辟现场保护区，以保存发生系统调用时应用程序的处理器现场

![image-20210104234130075](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210104234130075.png)

比如说在汇编语言里面，有个 INT n，这里的n就是中断类型码

内存里有一个中断向量表，就是这里的入口地址表，根据n，我们可以找到中断向量，也就是中断处理程序的入口地址，然后进行执行

> 系统调用和中断的关系？
>
> 系统调用是一种中断，OS内核是中断驱动的，中断是激活OS的唯一方式

## 中断的分类

* （狭义）**中断**/**异步中断**：处理器之外的中断事件——又称**外中断**
	* 可屏蔽、不可屏蔽
	* IO中断、时钟中断、外部信号中断
* **异常**：当前运行指令引起的中断，处理器内部的中断信号——**内中断**
	* 地址异常（超出范围）、算术异常、处理器硬件故障...
* 系统异常：执行陷入指令而触发系统调用
	* 请求设备、请求IO、创建进程等

## 中断的实现机制？

中断需要软硬件配置

* 硬件part

	![image-20210105141338464](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105141338464.png)

* 软件part

	同上面系统调用

	* 用户模式到内核模式 
		* 由中断/异常/系统调用中断用户进程 执行而触发 
			1. 处理器模式转为内核模式 
			2. 保存当前进程的PC/PSW值到**核心栈** 
			3. 转向中断/异常/系统调用处理程序
	* 内核模式到用户模式
		* OS执行中断返回指令将控制权交还 用户进程而触发
			1. 从待运行进程核心栈中弹出PSW/PC值 
			2. 处理器模式转为用户模式

	> ![image-20210105141430103](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105141430103.png)

	多中断的情况下也有讲究

	<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105142556687.png" alt="image-20210105142556687" style="zoom: 50%;" />

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105142623667.png" alt="image-20210105142623667" style="zoom:50%;" />

## 进程是什么？有哪些定义？

* 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动 
* 进程是操作系统进行资源分配和调度的一个独立单位
* 进程的五个实体部分**（P,C,D,R,PSW）**
	* (OS管理运行程序的)数据结构P 
	* (运行程序的)内存代码C 
	* (运行程序的)内存数据D 
	* (运行程序的)通用寄存器信息R 
	* (OS控制程序执行的)程序状态字信息PSW

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105152602369.png" alt="image-20210105152602369" style="zoom:50%;" />

某一时刻进程的内容及其执行状态集合： 

* 进程**控制块**: 保存进程的标识信息、状态信息和控制信息 
* 进程**程序块:** 进程执行的程序空间 
* 进程**数据块**: 进程处理的数据空间，包括数据、处理函数的用户栈和可修改的程序 
* **核心栈**: 每个进程绑一个，进程在内核态工作时用，保存中断/异常现场，也用于传参、返回地址等。
	* 进程在内核模式下运行时使用的堆栈，中断或系统过程使用进程映像是内存级的物理实体，又称为**进程的内存映像**

## OS怎么感知进程？

通过PCB

系统在创建进程时候建立PCB，进程运行结束才回收，进程借助PCB才能被调度执行

* **标识信息**：唯一标识进程的信息
	* 系统分配的、用户定义的标识号、进程组标识号
* **现场信息**：用于存放该进程运行时的处理器现场信息
* **控制信息**：用于存放与管理、调度进程相关的信息

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105152018329.png" alt="image-20210105152018329" style="zoom:67%;" />

## 怎么理解线程？

传统的进程存在一些问题

存在问题

* 进程切换开销大
* 进程通信开销大
* 限制了进程并发效率
* 降低并行计算效率

通过引入线程，进程的作用变为：

* **独立分配资源**
	* 仍有进程完成，作为系统资源分配和保护的基本单位
* **被调度分派执行**
	* 交给称作“线程”的实体来完成
	* “线程”作为系统调度和分派的基本单位

线程又分为OS感知线程和OS不感知线程

* KLT：OS提供了一个应用 程序设计接口API， 供开发者使用KLT
	* 进程中的一个线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行 
	* 多处理器环境中，内核能同时调度同一进程中多个线程并行执行 
	* 内核级线程数据结构和堆栈小，切换快
	* 线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要“用户态—内核态—用户态”切换，系统开销较大
* ULT
	* 线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在
	* 不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行
	* 一个ULT的阻塞，将引起整个进程的阻塞
* 混合级：有的是ULT，有的是KLT

> JAVA里的线程：混合级
>
> 1、证明java线程不是纯粹用户级线程：在java中起一堆线程，系统可以感知到。从java应用程序中的某个线程阻塞，是不会引起整个进程的阻塞，从这两点看，java线程绝不是纯粹的用户级线程。 （线程发生I/O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程）
>
> 2、再来，证明java线程不是纯粹内核级线程：这点比较直观，如果使用纯粹的内核级线程，那么有关线程的所有管理工作都是内核完成的，用户程序中没有管理线程的代码。显然，java线程库提供了大量的线程管理机制，因此java线程绝不是纯粹的内核级线程。 综上，java线程是混合型的线程模型，一般而言是通过lwp将用户级线程映射到内核线程中。

## 谈谈调度算法？

* 高级调度，又称作业调度、长程调度
	* 挑选作业进入内存，并为其分配所需资源并创建作业对应的用户进程
	* 控制多道程序的道数
* 中级调度，又称平衡负载调度
	* 决定主存中的可用进程集合
	* 内存紧缺时将不能运行的进程换出内存，"挂起"
	* 内存富裕时，重新调回内存
* 低级调度，又称进程调度、短程调度
	* 决定哪个可用进程占用处理器执行

## 调度算法？

* FCFS 先到先服务 非抢占式
* RR 时间片轮转 抢占式
	* 抢占时间：时间片用完
* SPN 最短进程优先 非抢占式
	* 抢占时间：进程到来/结束时，需要预估时间
* SRT 最短剩余时间优先 抢占式
	* 抢占时间：进程到来/结束时，需要预估时间
* HRRN 最高相应比优先 非抢占式
	* highest response ratio next
* feedback 多级反馈队列 抢占式
	* Q：如何照顾低优先级队列？
	* A：给长一点时间

## 知道孤儿进程和僵尸进程吗

[孤儿进程与僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)

## 存储管理有哪些功能？

* 地址转换：把逻辑地址转化为物理地址
* 存储分配：存储空间的分配去配
* 存储保护：越界检查
* 存储共享
* 存储扩容：使用虚存的概念，程序执行的指令或数据在磁盘上，部分装入；如果没用足够的空闲内存空间，部分替换

## 存储管理有哪些模式？

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. **段页式**

## 段式和页式的区别

1. 共同点
	- 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
	- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。
2. 区别
	- 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
	- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

## 页面替换算法？

* **OPT/最佳/Belady调度算法**

	* 当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页

* **FIFO**

	* 总是淘汰最先调入主存的那一页，或者说主存驻留时间最长的那一页

	* 可能出现belady异常

		> 使用4个页框时的缺页次数比3个页框时的缺页多，因此这种奇怪的情况称为Belady异常

* **LRU**

	* 淘汰最近一段时间较久未被访问的那一页
	* 模拟了程序执行的局部属性，既考虑了循环性又兼顾了顺序性

* **LFU**

	* 淘汰最近一段时间内访问次数较少的页面，对OPT的模拟性比LRU更好

* **CLOCK**

	* 页面调入主存时，其引用标志位置1 
	* 访问主存页面时，其引用标志位置1 
	* 淘汰页面时，从指针当前指向的页面开始扫循环队列 
		* 把所遇到的引用标志位是1的页面的引用标志位清0，并跳过 
		* 把所遇到的引用标志位是0的页面淘汰，指针推进一步

## 反置页表是什么？为什么需要反置页表

先说说为什么需要反置页表

大多数的操作系统会为每个进程提供一个页表，如果有很多进程同时运行，那么内存中将会有很大一部分被页表占用。多级页表并不能解决这个问题，因为多级页表也是一个进程维护一张页表。反置页表可以解决这个问题。

使用反置页表的话，所有进程共同使用一张页表，这张页表中的条目的数量和内存中物理的页框的数量是一样的。

![image-20210105203555963](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105203555963.png)



## 段页式

![image-20210105204753521](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105204753521.png)

![image-20210105204800993](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105204800993.png)

## 说说inode？

Inode存储了文件系统对象的一些元信息，如所有者、访问权限（读、写、执行）、类型（是文件还是目录）、内容修改时间、inode修改时间、上次访问时间、对应的文件系统存储块的地址，等等

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210108165201956.png" alt="image-20210108165201956" style="zoom:67%;" />

* **用户打开文件表**

	* 进程的PCB结构中保留一个files_struct，称为**用户打开文件表或文件描述符表**

	* 表项的序号为文件描述符**fd**，该登记项内登记系统打开文件表的一个入口指针**fp**
	* 通过此系统打开文件表项连接到打开文件的活动inode

* **系统打开文件表**

	* 由于一个文件可以被多个进程同时打开或一个进程同时打开多次，带来了如何管理文件当前位移量的问题
	* 是为解决多用户进程共享文件、父子进程共享文件而设置 的系统数据结构file_struct
	* 不管是同一个进程还是不同进程，每当打开一个文件时，通过此表项把用户打开文件表的表项与文件活动inode联接起来，以实现数据的访问和信息的共享
	* 多个file可以对应同一个inode，一个node可以连接0个或者多个file

* **主存活动inode表**

	* 把常用和正在使用的那些文件目录复制进主存，这样既不增加太多主存开销，又可明显减少查找时间
		* 系统为每个用户进程建立一张**活动文件表**，用户使用文件之前先通过“打开”操作，把该文件的文件目录复制到指定主存区域
		* 当不再使用该文件时，使用“关闭”操作切断和该文件目录的联系，这样，文件被打开后，可被用户多次使用，直至文件被关闭或撤销，大大减少访盘次数，提高文件系统的效率。
	* `i_count`反应共享inode的进程数目，是关闭文件时活动inode能否释放的依据
	* `i_nlink`连接计数，决定删除文件时是否将占用的存储空间释放

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210108170401525.png" alt="image-20210108170401525" style="zoom:80%;" />

## 死锁产生的条件

* 互斥条件(mutual exclusion)：系统中存在临界资源，进程应互斥地使用这些资源
* 占有和等待条件(hold and wait)：进程请求资源得不到满足而等进程请求资源得不到满足而等待时，不释放已占有的资源 
* 不剥夺条件(no preemption)：已被占用的资源只能由属主释放，不允许被其它进程剥夺
* 循环等待条件(circular wait)：存在循环等待链，其中，每个进程都在链中等待下一个进程所持有的资源，造成这组进程永远等待

## CPU寻址？

* 直接寻址，偏移地址值直接出现在执行代码中

	```assembly
	mov 寄存器，[偏移地址]
	mov [偏移地址]，寄存器
	```

* 寄存器间接寻址，偏移地址通过寄存器取得

	```assembly
	mov 寄存器，[寄存器]
	mov [寄存器]，寄存器
	```

* 寄存器相对寻址，偏移地址值通过[寄存器+偏移量值]的形式运算后获得

	```assembly
	mov 寄存器,[寄存器+偏移量值]
	mov 寄存器,ds:[寄存器+偏移量值]
	mov [寄存器+偏移量值]，寄存器
	mov ds:[寄存器+偏移量值]，寄存器
	```

	![image-20201017184431823](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201017184431823.png)

* 基址加变址寻址，偏移地址值通过[基址寄存器+变址存储器]的形式运算后获得

	```assembly
	mov ax,[bx+si]
	add word [bx+di],0x3000
	```

* 相对基址加编址寻址

	```assembly
	mov 寄存器,[基址寄存器+变址寄存器+偏移量值]
	mov [基址寄存器+变址寄存器+偏移量值],寄存器
	```

## epoll

https://zhuanlan.zhihu.com/p/63179839

https://zhuanlan.zhihu.com/p/64138532

https://zhuanlan.zhihu.com/p/64746509