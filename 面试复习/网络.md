# 网络

![](https://images.xiaozhuanlan.com/photo/2019/497a4707a94614e44401023c95015316.jpg)

## 应用层

> 报文 message

### OSI

会话、表示、应用层

会话层

* 作用：建立、管理、终止应用程序之间的会话
	* 例如是半双工还是其他的（传输层确定能通信，会话层确定怎么通信）
* checkpoint 检查点
	* 把会话分割成明显的会话单元session，过去的成为对话dialogue
	* 会话分离是有序地初始化、终止和管理通讯
	* 这样当网络出现故障就从最后一个检查点开始重传数据（下载100M的文件，下载到95M网络断线只需要再次下载最后5M）

展示层

* 负责以接收设备可理解的方式呈现数据

* 格式化数据
	* ASCII和EBCDIC
	* GIF和JPEG
* 压缩数据
* 数据加密

### 应用层协议?

* HTTP	

	* 超文本传输协议
	* URL := `<URL的访问方式>://<主机>:<端口>/<路径>`

		* 无状态的
		* 无连接的，虽然使用了面向连接的TCP

* FTP

	* 使用TCP，可靠、面向连接的服务
	* 首先建立**控制**连接 **21端口**
	* 然后建立**数据**传输需要的连接 **20端口**

* TFTP

	* UDP
	* 小且容易实施

* Telnet

	* 远程登录

* SMTP POP IMAP

	* TCP

	* ![image-20210226195429347](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226195429347.png)

	* ![image-20210226195438347](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226195438347.png)

	* >   **IMAP和POP有什么区别？** 
		>
		>    POP允许电子邮件客户端下载服务器上的邮件，但是您在电子邮件客户端的操作（如：移动邮件、标记已读等），这是不会反馈到服务器上的，比如：您通过电子邮件客户端收取了QQ邮箱中的3封邮件并移动到了其他文件夹，这些移动动作是不会反馈到服务器上的，也就是说，QQ邮箱服务器上的这些邮件是没有同时被移动的  。但是IMAP就不同了，电子邮件客户端的操作都会反馈到服务器上，您对邮件进行的操作（如：移动邮件、标记已读等），服务器上的邮件也会做相应的动作。也就是说，IMAP是“双向”的。 
		>
		>   同时，IMAP可以只下载邮件的主题，只有当您真正需要的时候，才会下载邮件的所有内容。 

* MIME

	* 将非ASCII码转为ASCII码

* DNS

	* 域名解析，域名翻译成IP

	* www.sina.com 从左到右 为第3、第2、顶层域名

	* 两种形式：递归、迭代

		![image-20210226194354924](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226194354924.png)

### 在浏览器中输入url地址 ->> 显示主页的过程

详细参考https://segmentfault.com/a/1190000006879700

1. DNS解析
	* 优化：浏览器缓存，系统缓存（host文件），路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存
2. TCP连接
3. HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
	* 插叙：前端优化，如CSS精灵、CDN、懒加载等
6. 连接结束

### 谈谈TCP中的长连接和短链接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接

### 为什么说http协议是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）

### 既然http协议是无状态的，那么如何保存用户状态？

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP   协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session  的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP  协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session  存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID  来方式来跟踪。

> cookie被禁用？
>
> 最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。

### Cookie的作用是什么？和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie  中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token  重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### HTTP1.0 HTTP1.1 HTTP2.0

* HTTP1.1 
	* **长连接** : **在HTTP/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1起，默认使用长连接** ,默认开启Connection： keep-alive。
	*  **HTTP/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

* HTTP2.0
	* **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
	* **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
	* **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

### URI URL

- URI(Uniform Resource Identifier) 是同一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是同一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### HTTP和HTTPS

SSL：（Secure Socket  Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。

TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

https://segmentfault.com/a/1190000018992153

### HTTPS是什么?

https://zhuanlan.zhihu.com/p/43789231



## 传输层

> segment

* 将应用层数据分段
* 建立端到端的操作
* 将segment从主机发送到主机
* 流量控制和可靠性

### 谈谈路由器转发的过程？

1. 提取IP数据报告首部中的目的IP地址
2. 判断目的IP地址所在的网络是否与本路由器直接相连。如果是，就直接交付给目的网洛：如果不是执行3）
3. 检查路由器表中是否有目的IP地址的特定主机路由。如果有，按特定主机路由转发：如果没有，执行4）
4. 逐条检查路由表。若找到匹配路由，则按照路由表进行转发：若所有路由均不匹配，则执行5
5. 若路由表中设置有默认路由，则按照默认路由表转发：否则，执行6）
6. 向源主机报错。

MAC地址的变化如下：

A-----(B1-B2)-----(C1-C2)-------E


假设拓扑图是这个样子吧，B1和B2是路由器B上的两个接口，C1和C2是路由器C上的两个接口，A和E是PC，由主机A向主机E发送数据包，那么在主机A形成的数据包的目的IP就是E的IP，源IP就是主机A的IP地址，目标MAC地址就是B1的MAC地址，源MAC地址就是A的MAC地址

由A发给路由器B，B经过重封装后，源IP和目标IP是不变的，源MAC地址变成B2的MAC地址，目标MAC地址变成C1的MAC地址，封装完成发送给路由器C，路由器C接收到数据包后和B做的操作是一样的，源IP和目标IP的不变的，源MAC地址变成C2的MAC地址，目标MAC地址变成主机E的MAC地址，然后发送给主机E，这样E就收到了这个数据包，当恢复数据包的时候就是把收到的数据包的源IP地址（主机A的IP地址）和源MAC地址（接口C2的MAC地址）作为他的目标IP和目标MAC地址

### TCP报文

![image-20210226220857876](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226220857876.png)

###  三次握手及相关问题

![image-20200818200236673](https://img2020.cnblogs.com/blog/1958143/202008/1958143-20200820094900154-1369704410.png)

* 第一次握手：客户端发送一个SYN=1，ACK=0的TCP段
* 第二次握手：服务端发送一个SYN=1，ACK=1的TCP段
	* 如果没有监听端口，返回一个RST=1的TCP段
* 第三次握手：客户端发送一个SYN=0，ACK=1的TCP段

> Q1：为什么要三次握手？
>
> 主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
>
> 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。
>
> Q2：为什么要传回SYN？
>
> 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了
>
> Q3：传了 SYN,为啥还要传 ACK
>
> 双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证

### 四次挥手及相关问题

![image-20210316192053481](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210316192053481.png)

* 客户端发送一个FIN=1的报文
	* 进入进入FIN-WAIT-l (终止等待1)状态，等待服务器的确认。
* 服务器发送FIN=0，ACK=1的确认报文
	* 进入CLOSEWAIT(关闭等待)状态，TCP 服务器进程这时应通知高层应用进程
	* (half-close)状态，即A 己经没有数据要发送了，但B 若发送数据， A 仍要接收。
	* A 收到来自B 的确认后，就进入FIN-WAIT-2 (终止等待2) 状态
* 若服务器没有要发送的报文了，就向客户端发送FIN=1的释放报文
	* **确认号仍要和前述的一致**
	* B 就进入LAST-ACK (最后确认)状态
* 客户端收到连接释放报文后，发送FIN=0,ACK=1的确认报文
	* 客户端进入TIME-WAIT (时间等待)状态，**TCP连接还没释放！**
	* 必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL 后， A 才进入到CLOSED 状态

> Q1:为什么要等2MSL（Maximum Segment Lifetime）
>
> 防止第四条B没有收到，经过2MSL后会收到B会重新发送的第三条
>
> Q2:关于确认号
>
> 注意见图！很重要
>
> Q3:为什么建立连接是三次握手，关闭连接确是四次挥手呢？
>
> 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
> 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次

### TCP vs UDP

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP  要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

### TCP怎样保证可靠传输

1. **校验和**： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

2. TCP 的接收端会丢弃重复的数据。 

3. **流量控制**：使用可变滑动窗口来进行控制

	![image-20210311220153152](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210311220153152.png)

4. **拥塞控制**：当网络拥塞时，减少数据的发送

5. **ARQ**：维护一个发送窗口，收到一个确认后发送窗口向前滑动

6. **超时重传**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### 谈谈拥塞控制的四个算法

https://blog.csdn.net/qq_41431406/article/details/97926927

1. **慢开始**

	假设当前发送方拥塞窗口cwnd的值为1，而发送窗口swnd等于拥塞窗口cwnd，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值乘2

	当前的拥塞窗口cwnd的值已经等于慢开始门限值，之后改用拥塞避免算法。

2. **拥塞避免**

	也就是每个传输轮次，拥塞窗口cwnd只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口cwnd按指数增长

	理，16+1……直至到达24，假设24个报文段在传输过程中丢失4个，接收方只收到20个报文段，给发送方依次回复20个确认报文段，一段时间后，丢失的4个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改cwnd和ssthresh.并重新开始慢开始算法，如图所示

	![image-20210226223442720](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226223442720.png)、

	> 拥塞避免并非指能完全避免，只是比较不容易产生拥塞

3. **快重传**

	![image-20210226223607033](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226223607033.png)

4. **快恢复**

	![image-20210226223702254](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210226223702254.png)

## 数据链路层

> **封装成帧**，**透明传输**和**差错检测**

MAC地址+循环冗余校验

TCP校验和覆盖TCP首部和TCP数据，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。TCP校验和、IP校验和的计算方法是基本一致的，除了计算的范围不同。

TCP的校验和是必需的，而UDP的校验和是可选的。TCP和UDP计算校验和时，都要加上一个12字节的伪首部。

## 物理层

### 任务

透明地传输比特流

### 信道复用技术

1. **频分复用(FDM)** ：所有用户在同样的时间占用不同的带宽资源。
2. **时分复用（TDM）** ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。
3. **统计时分复用 (Statistic TDM)** ：改进的时分复用，能够明显提高信道的利用率。
4. **码分复用(CDM)** ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。