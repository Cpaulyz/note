# JVM

## 内存

### 介绍下 Java 内存区域（AKA运行时数据区）

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309153224314.png" alt="image-20210309153224314" style="zoom:67%;" />

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309153240177.png" alt="image-20210309153240177" style="zoom:67%;" />

* **堆**

	此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存

	GC发生的区域，分为新生代、老年代，新生代又分为Eden和Survivor区，Survivor区有from区和to区

* **方法区**

	用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等

	类加载器将 .class 文件搬过来就是先丢到这一块上

* **虚拟机栈**

	代码的运行空间，每个方法执行时会有自己的栈帧，存放局部变量表（各种数据类型boolean、byte、char、short、int、float、long、double、对象引用reference 类型）。方法return或者抛出异常时候，会释放栈空间

	生命周期同线程

* **本地方法栈**

	虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

* **程序计数器**

	线程独享，两个作用

	1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
	2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

	==唯一不会OOM的区域==

### JDK1.8的变化，怎么理解？

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

**JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**

1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

1. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
2. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

### Java 对象的创建过程

![image-20210309154120262](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309154120262.png)

1. **类加载检查**

	虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

2. **分配内存**

	对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来

3. **初始化零值**

	虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

4. **设置对象头**

	初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的**元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。**

5. **init**

	构造函数

### 对象头有哪些内容

对象头中包含两部分: MarkWord 和 类型指针.

如果是数组对象的话, 对象头还有一部分是存储数组的长度.

多线程下synchronized的加锁就是对同一个对象的对象头中的MarkWord中的变量进行CAS操作.

* **MarkWord**	

  Mark Word用于存储对象自身的运行时数据, 如HashCode, GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID等等.
  占用内存大小与虚拟机位长一致(32位JVM -> MarkWord是32位, 64位JVM->MarkWord是64位).

  ![image-20210310213926968](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210310213926968.png)

* **类型指针**

	类型指针指向对象的类元数据, 虚拟机通过这个指针确定该对象是哪个类的实例.

### 对象创建时内存分配的两种算法

取决于 Java 堆内存是否规整

![image-20210309154819622](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309154819622.png)

1. **指针碰撞法**

	堆内存规整时，可以理解为用过的内存全都在一边，空闲的在另外一边，这样就有一个中间位置，可以用一个指针指向，只要向空间的的内存方向移动指针即可分配内存。类似OS的栈顶指针

	Seiral、ParNew

2. **空闲列表法**

	堆内存不规整时，维护一个列表，记录哪些块可用。分配时从列表中找一个足够大的内存块来分配给示例对象，并更新列表

	CMS

> 并发问题？
>
> 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

### 对象的访问定位的两种方式

* **句柄**

	<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309155348376.png" alt="image-20210309155348376" style="zoom: 67%;" />

	Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

	好处在于，GC的时候只需要更新句柄就可以了

* **直接指针**

	Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址

	![image-20210309155435230](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309155435230.png)

	好处在于，速度快，节省了一次指针定位的时间开销

## GC

> https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6

### 什么需要survivor区

1. 减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代，避免频繁的Full GC
2. 两个survivor区，解决了碎片化的问题（复制算法）

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309092105429.png" alt="image-20210309092105429" style="zoom:67%;" />

### 怎样进入老年代

* **大对象直接进入老年代**

	大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

	为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

* **长期存活的对象进入老年代**

	每个对象都有一个age计数器

	如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

### 如何判断对象死亡

* **引用计数法**

	给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

	难以解决循环依赖问题

* **可达性分析**

	这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

### 可作为 GC Roots 的对象包括下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

### 垃圾收集器

* **Serial收集器**

	串行，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束

	**新生代采用标记-复制算法，老年代采用标记-整理算法**

	![image-20210309155709468](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309155709468.png)

* **ParNew收集器**

  Serial的多线程版本

  **新生代采用标记-复制算法，老年代采用标记-整理算法。**


* **Parallel Scavenge算法**

* **CMS**

  回收器是针对老年代垃圾回收，**“标记-清除”算法**实现，会有大量空间碎片

  ![image-20210309160024530](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210309160024530.png)

  * 初始标记：停止用户线程，记录下直接与 root 相连的对象和年轻代中活着的对象引用到的老年代的对象，找出所有存活的对象
  * 并发标记：因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况
  * 重新标记：停止用户线程，重新标记的内存范围是整个堆
  * 并发清除(CMS-concurrent-sweep)：与用户线程同时运行；

* **G1**

### 垃圾收集算法

* 标记-清除
* 标记-复制
* 标记-整理

* 分代收集

### 四种引用类型

https://www.cnblogs.com/liyutian/p/9690974.html

## 类加载

### 类加载过程

* **加载**

	1. 将class文件加载到内存
	2. 将静态数据结构转化成方法区中运行时的数据结构
	3. 在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口

* **连接**

	1. 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查
	2. 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）
	3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）

* **初始化**

	1. 保证执行前父类初始化完毕
	2. 顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句

* **卸载**

	GC将无用对象从内存中卸载

### ClassLoader

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

### 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

1. Bootstrap ClassLoader启动类加载器：默认会去加载JAVA_HOME/lib目录下的jar
2. Extention ClassLoader扩展类加载器：默认去加载JAVA_HOME/lib/ext目录下的jar
3. Application ClassLoader应用程序类加载器：比如我们的web应用，会加载web程序中ClassPath下的类
4. User ClassLoader用户自定义类加载器：由用户自己定义

![image-20210311211655135](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210311211655135.png)

### 你觉得双亲委派这名字有没有问题？

有

Parent Delegation Model 

其实没有“双”，只有亲

### 为什么需要双亲委派?

1. 防止核心库被随意篡改，比如自己写的string.class不会被加载
2. 避免重复加载，当父ClassLoader已经加载该类的时候，就不需要子ClassLoader在加载一次