# SQL

### B树结构

* 结构

	所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接

* 能做什么

	* 全键值查询，如`where x=123`
	* 键范围查询，如`where 45<x<123`
	* 键前缀查询，如`where x like "J%"`

* 不能做什么

	后缀查询

### MyISAM vs InnoDB

* MyISAM使用前缀压缩以减少索引，而InnoDB不会压缩索引，（有啥差别？） 

	https://www.cnblogs.com/xiaoboluo768/p/5166939.html

* MyISAM索引按照行存储的物理位置引用被索引的行，但是InnDB按照主键值引用行，（有啥差别?

	https://blog.csdn.net/qq_35642036/article/details/82820178

### 如何让索引发挥作用

* 复合索引

	本质上索引是按照排名第一的字段进行的索引，最左匹配

* 回表查询

	使用聚集索引，或者查询字段被索引覆盖时候，可以只使用索引，不使用表

### 索引与外键

系统地对表的外键加上索引的做法非常普遍

* 为什么

	以MySQL为例，InnoDB提供了四种外键关联策略

	* RESTRICT（默认）：父表在删除和更新记录的时候，要在子表中检查是否有有关该父表要更新和删除的记录，如果有，则不允许删除和更改
	* CASCADE：级联删除或更改
	* NO ACTION：什么也不做
	* SET NULL：置空，当父表更新、删除的时候，字表会把外键字段变为null，所以这个时候设计表的时候该字段要允许为null，否则会出错

	可以看出，在外键字段上，如果主表发生了变化，通常会对从表进行修改，这就需要在外键字段上进行查询，如果没有加上索引，需要对从表进行全表遍历

* 有例外吗？

	主表不会改变时，或者外键约束为NO ACTION

### 索引组织表*

https://www.cnblogs.com/nieliu/archive/2012/05/04/2482223.html

索引组织表(index organized table, IOT)就是存储在一个索引结构中的表。存储在堆中的表是无组织的(也就是说，只要有可用的空间，数据可以放在任何地方)，IOT中的数据则按主键存储和排序。对你的应用来说，IOT表和一个“常规”表并无二致。

索引组织表的数据按主键排序手段被存储在B-树索引中，除了存储主键列值外还存储非键列的值。普通索引只存储索引列，而索引组织表则存储表的所有列的值。

索引组织表一般适应于静态表，且查询多以主键列。当表的大部分列当作主键列时，且表相对静态，比较适合创建索引组织表！（8i以上）

既然它属于表，那么它当然也有建立索引的需求。由于它的索引的结构，比如说由于索引叶节点的分裂，行所在块可能会发生改变，因而建立在IOT上的索引和一般的索引的最大区别是它存的是IOT的行的逻辑地址，也就是UROWID，oracle用这个逻辑rowid来猜这个行所在的块，如果猜到了，那么这个urowid是正确的，否则它从这个地址向下遍历来找这条记录。

IOT表的rowid是逻辑上的，因为IOT表中的行的位置是在不断变化的(例如插入新的行，有可能带来其它行的位置移动)

  IOT有什么意义呢？使用堆组织表时，我们必须为表和表主键上的索引分别留出空间。而IOT不存在主键的空间开销，因为索引就是数据，数据就是索引，二者已经合二为一。但是，IOT带来的好处并不止于节约了磁盘空间的占用，更重要的是大幅度降低了I/O,减少了访问缓冲区缓存(尽管从缓冲区缓存获取数据比从硬盘读要快得多，但缓冲区缓存并不免费，而且也绝对不是廉价的。每个缓冲区缓存获取都需要缓冲区缓存的多个闩，而闩是串行化设备，会限制应用的扩展能力)

   IOT适用的场合有：
 1、完全由主键组成的表。这样的表如果采用堆组织表，则表本身完全是多余的开销，因为所有的数据全部同样也保存在索引里，此时，堆表是没用的。
 2、代码查找表。如果你只会通过一个主键来访问一个表，这个表就非常适合实现为IOT.
 3、如果你想保证数据存储在某个位置上，或者希望数据以某种特定的顺序物理存储，IOT就是一种合适的结构。

  IOT提供如下的好处：
 ·提高缓冲区缓存效率，因为给定查询在缓存中需要的块更少。
 ·减少缓冲区缓存访问，这会改善可扩缩性。
 ·获取数据的工作总量更少，因为获取数据更快。
 ·每个查询完成的物理I/O更少，因为对于任何给定的查询，需要的块更少，而且对地址记录的一个物理 I/O 很可能可以获取所有地址（而不只是其中一个地址，但堆表实现就只是获取一个地址）

  如果经常在一个主键或惟一键上使用BETWEEN 查询也是如此，因为相近的记录存在一起，查询时引入的逻辑IO和物理IO都会更少。

### 系统生成键

* 系统生产序列号，远好于 
	* 寻找当前最大值并加1 
	* 用一个专用表保存”下一个值“且加锁更新
* 但如果插入并发性过高，在主键索引的创建操作上会发生十分严重的资源竞争
* 解决方案
	* 反向键索引或叫逆向索引（reverse index）
	* 哈希索引（hash indexing

### SQL执行顺序

![image-20210422174146262](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210422174146262.png)

* 最复杂：解析（最耗资源，但不是最重要的

	绑定变量：https://blog.csdn.net/maray/article/details/7663598

* 最重要：执行

### 绑定变量

提到绑定变量，首先肯定想到硬解析和软解析。绑定变量时解决硬解析的利器。

* 硬解析：就是一条没有执行过的sql。数据库首先对他进行语法分析和解析，过后，根据分析的信息生成最好的执行计划，然后执行。

* 软解析：就是已经存在了一样的sql语句了

绑定变量实质就是变量。类似于我们是用过的替代变量（占位符）。就是在sql语句中使用变量，通过改变变量的值来得到不同的结果。

sql语句是分为动态部分和静态部分的。而动态部分在一般的情况下，对执行计划的影响是微乎其微的。所以同一个sql语句有不同动态部分生成的执行计划是相同的。

* 优点：

	使用动态绑定，可以减少sql的解析，从而减少了数据库引擎在sql解析上资源的消耗。提高了执行效率和可靠性。减少对数据库的访问实际上就是减少了数据库的工作量

* 缺点：

	可能长时间使用动态sql，由于参数的不同。可能sql的执行效率不同。

### SQL优化

* 影响因素

	* 结果集的大小

		取决于表的大小和过滤条件的细节

	* 表的数量

		对于优化器，随着表数量的增加，复杂度呈指数增长

		编写太多复杂查询时，多种方式的连接选择失误率高

* 过滤条件，满足越少越好，-》 用exist in 来暗示

	基本原则：

	* 外层条件好，用exists
	* 外层条件不好，用in
	* 不知道的情况下，用in

* 降低表连接数量-》打破范式

### 隔离级别（必考简答）

PPT

