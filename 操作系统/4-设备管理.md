# 第4章 设备管理

## 4.1 设备管理概述 

* I/O设备又称为外围设备或外部设备，简称外设
*  I/O操作：内存和I/O设备之间的信息传送操作

###  分类

* 按信息传输方向划分 
	* 输入设备：将外界信息输入计算机 
		* 例如：键盘，鼠标，扫描仪等 
	* 输出设备：将计算结果输出 
		* 例如：显示器，打印机等 
	* 输入输出设备：既可以输入信息，也可以输出信息 
		* 例如：磁盘驱动器，网卡等
* 按交互功能划分 
	* 人机交互设备：用于用户与计算机之间的交互通信
		* 例如：鼠标，键盘，显示器等 
	* 存储设备：持久性地存储大量信息并快速检索
		* 例如：磁盘驱动器，光盘驱动器等 
	* 机机通信设备：用于计算机和计算机之间的通信
		* 例如：网卡，调制解调器等
* 按设备管理划分 
	* 字符设备：以字符为单位进行信息交换，发送或接收一个字符流 
		* 人机交互设备大多是字符设备，例如鼠标、显示器等 
	* 块设备：以固定大小的数据块（块是存储介质上连续信息组成的一个区域）进行信息交换 
		* 存储设备通常为块设备，例如磁盘驱动器等 
	* 网络设备：用于与远程设备通信的设备
		* 机机通信设备为网络设备，例如网卡等
		* 网络设备可以抽象为传送字符流的特殊字符设备，也 可以抽象为传送连续小块数据的块设备

### 目标

1. 克服设备和CPU速度的不匹配所引起的问题，使主机和设备并行工作，提高设备使用效率
2. 对设备进行抽象，屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面，供用户或高 层软件使用

### 设备管理的功能

* 设备中断处理 
* 缓冲区管理 
* 设备的分配和去配 
* 设备驱动调度 
* 实现虚拟设备

### 设备管理的层次

* I/O硬件
	* I/O设备及其接口线路 
	* 控制部件 
	* 通道 
* I/O软件 
	* 系统I/O软件 
	* 用户空间I/O软件

## 4.2 I/O控制方式

### 设备控制器

* I/O设备中由机械部件和电子部件组成，为达到模块化和通用性的设计目标，通常将I/O设备中的机械部件和电子部件分开处理 其中，电子部件称为设备控制器
* 设备控制器又称为设备适配器、I/O控制器、I/O 控制接口，简称I/O模块或I/O接口
* **操作系统与控制器交互，而非与设备交互**
* 设备控制器是CPU与设备之间的接口，**主要功能是**
	* 接收和识别CPU或通道发来的命令 
	* 实现数据交换 
	* 发现和记录设备及自身的状态信息，供CPU处理使用 
	* 当连接多台设备时，设备地址识别

![image-20210105230518868](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105230518868.png)

### IO控制方式-轮询

* 又称程序直接控制方式
* 例：CPU控制程序需要从设备读入一批数据
	1. CPU程序设置交换字节数和数据读入的内存起始地址
	2. 向设备发出查询指令（忙式查询）
	3. 就绪后，开始数据传输，CPU从IO接口读取一个字，采用存储指令存到内存
	4. 如果传输尚未结束，再次发出查询，直到完成

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105230530390.png" alt="image-20210105230530390" style="zoom:67%;" />

缺点：

* 等待I/O操作完成后，才可以继续其它操作（串行）
* CPU参与传输工作

### IO控制方式-中断

* 要求CPU与设备控制器之间存在中断请求线，设备控制器的状态寄存器由相应的中断允许位

1. 进程发出IO指令，这时候CPU会将控制信息加载到设备控制器的寄存器，然后CPU继续执行不涉及本次IO数据的任务，或放弃CPU等待设备IO完成
2. 设备控制器检查状态寄存器内容，按照IO指令的要求执行相应IO操作，一旦传输完成，设备控制器通过中断请求线发出IO中断信号
3. CPU收到并响应IO后，转入IO中断处理程序
4. 中断处理程序执行数据读取，将IO缓冲寄存器的内容写入内存
5. 进程调度在适当时刻让得到数据的进程恢复执行

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105232812905.png" alt="image-20210105232812905" style="zoom:67%;" />

* 如果设备控制器的数据缓冲区较小，缓冲区装满后就会中断，那么在数据传过程中中断次数会较多
* CPU仍需参与数据传输
* CPU不必忙式轮询，可以充分并行

### IO控制方式-DMA

* 模仿处理器来控制主存和设备控制器之间的数据交换
* **设备直接与内存交换数据**而不用占用CPU
* DMA方式则是以数据块为单位传输的,在所要求传送的数据块全部传送结束时要求CPU进行中断处理,大大减少了CPU进行中断处理的次数

1. 处理器向DMA模块发出 I/O命令 
2. 处理器继续执行其它工作，DMA模块负责传送 
3. 全部数据数据传送结束后，DMA 中断处理器

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105233041006.png" alt="image-20210105233041006" style="zoom:67%;" />

CPU只在数据传送的开始和结束时参与

* 开始时，CPU需要对DMA模块进行初始化 
* 结束时，CPU响应中断，但不必保存现场

### IO控制方式-IO通道

* 背景：
	* DMA方式减少了CPU对IO操作的干预，但每发出一次IO指令，只能读写一个数据块
	* 希望一次能够读写多个离散数据块，并把它们传输到不同的内存区域或相反
	* 这需要由CPU发出多条IO指令及执行多次IO中断处理才能完成
* 通道：
	* 又称IO处理器，能够完成内存和设备之间的信息传输，与CPU并行地执行操作
	* 通道方式是DMA方式的发展
* 结构：主机、通道、设备控制器、设备之间采用四级连接，实施三级控制
	* 一个CPU可以连接若干通道
		* CPU通过执行IO指令对通道进行控制
	* 一个通道可以连接若干控制器
		* 通道通过执行通道命令对控制器实施控制
	* 一个控制器可以连接若干设备
		* 控制器发出动作序列对设备实施控制
* 流程
	1. CPU在遇到I/O请求，启动指定通道 
	2. 一旦启动成功，通道开始控制I/O设备进行操作， CPU执行其他任务
	3.  I/O操作完成后，I/O通道发出中断，CPU停止当前工作，转向处理I/O操作结束事件

### 总结与对比

![image-20210105233323117](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105233323117.png)

**DMA与通道的区别**：

* 与DMA方式不同的是，在DMA方式中，数据的传送方向、存放数据的内存始址以及传送的数据块长度等都由CPU控制，而在通道方式中，这些都由通道来进行控制。另外，DMA方式每台设备至少需要一个DMA控制器，一个通道控制器可以控制多台设备。

## 4.4&4.5 IO软件

* 设计目标
	* 高效率：改善设备效率
	* 通用性：用统一标准来管理设备
* 设计思路
	* 把软件组织成层次结构，低层软件用来屏蔽硬件细节， 高层软件向用户提供简洁、友善的界面
* 考虑问题
	* 设备无关性：编写访问文件的程序与具体设备无关 
	* 出错处理：低层软件能处理的错误不让高层软件感知 
	* 同步/异步传输： 支持阻塞和中断驱动两种工作方式 
	* 缓冲技术：建立数据缓冲区，提高吞吐率

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105233714129.png" alt="image-20210105233714129" style="zoom:67%;" />

### IO中断处理程序

* 进程请求I/O操作时，通常被挂起，直到数据传输结束后并产生I/O中断时，操作系统接管CPU后转向中断处理程序 

* 当设备向CPU提出中断请求时，CPU响应请求并 转入中断处理程序
	* 检查设备状态寄存器内容，判断产生中断的原因
	* 如果数据传输有错，向上层软件报告设备的出错信息，实施重新执行 
	* 如果正常结束，唤醒等待传输的进程，使其转换为就绪态 
	* 如果有等待传输的I/O命令，通知相关软件启动下 一个I/O请求

### IO设备驱动程序

把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行

每个设备驱动程序只处理一种设备，或者一类紧密相关的设备

* 笼统地说，设备驱动程序的功能是从独立于设备的软件中接受并执行IO请求
* 例如，读第n块，如果请求到来时驱动程序空闲，立即执行请求；如果它正在处理上一个IO请求，会将新来的请求放到IO队列中，在依次出队处理

### 独立于设备的IO软件

* 虽然设备驱动程序设备专用的，但大部分IO软件与设备无关
* 基本功能是执行适用于所有设备的常用IO功能，并向用户层软件提供一致性接口
	* 设备命名：通过路径名寻址设备 
	* 设备保护：检查用户是否有权访问所申请设备 
	* 提供与设备无关的数据单位：字符数量，块尺寸 
	* 缓冲技术：传输速率，时间约束，不能直接送达目的地 
	* 设备分配和状态跟踪：分配不同类型的设备 
	* 错误处理和报告：驱动程序无法处理的错误

### 用户空间的IO软件

* 库函数
	* 一小部分I/O软件不在操作系统中，是与应用程序链接在一起的库函数，甚至完全由运行于用户态的 程序组成
	* 系统调用通常由库函数封装后供用户使用
* SPOOLing软件
	* 在内核外运行的系统I/O软件，采用预输入、缓输出和井管理技术，通过创建守护进程和特殊目录解决独占型设备的空占问题

## 4.6 IO缓冲区

* **目的** 

	解决CPU与设备之间速度不匹配的矛盾，协调逻辑记录大小和物理记录大小不一致的问题，提高CPU和设备的并行性，减少I/O操作对CPU的中断次数，放宽对CPU中断响应时间的要求

* 操作

	* 写操作：将数据送至缓冲区，直到装满，进程继续计算，同时系统将缓冲区的内容写到设备上 
	* 读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程

### 单缓冲

操作系统在主存的系统区中开设一个缓冲区

* 输入：将数据读至缓冲区，系统将缓冲区数据送至用户区，应用程序对数据进行处理，同时系统读入 接下来的数据 
* 输出：把数据从用户区复制到缓冲区，系统将数据输出后，应用程序继续请求输出

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105234552651.png" alt="image-20210105234552651" style="zoom:67%;" />

### 双缓冲

使用两个缓冲区

* 输入：设备先将数据输入缓冲区1，系统从缓冲区1把数据传到用户区，供应用程序处理，同时设备将数据传送到缓冲区2 
* 输出：应用程序将数据从用户传送到缓冲区1，系统将数据传送到设备，同时应用程序将数据传送到缓冲区2

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105234638338.png" alt="image-20210105234638338" style="zoom:67%;" />

### 循环缓冲

操作系统分配一组缓冲区，每个缓冲区度有指向下一个缓冲区的链接指针，构成循环缓冲

类似双缓冲

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210105234724245.png" alt="image-20210105234724245" style="zoom:67%;" />

## 4.7 设备独立性

### 什么是设备独立性

* 系统需要提供逻辑设备名和物理设备名的对应表以供转换使用

* 作业执行前对设备提出申请时，指定某台具体的物理设备会让设备分配变得简单，但如果所指定设备出现故障，即便计算机系统中有同类设备也不能运行
* 用户通常不指定物理设备，而是指定逻辑设备，使得用户作业和物理设备分离开来，再通过其它途径 建立逻辑设备和物理设备之间的映射
* 设备的这种特性叫做“设备独立性”

### 优点

* 应用程序与具体物理设备无关，系统增减或变更 
* 设备时不需要修改源程序 易于应对I/O设备故障，提高系统可靠性 
* 增加设备分配的灵活性，更有效地利用设备资源， 实现多道程序设计

## 4.8 独占型外设的分配

* 独占设备 
	* 只能由一个进程独占式使用
	* 如卡片机、打印机、磁带等
* 分配方式
	* 静态分配：简单，能够防止系统发生死锁，但会降低设备利用率
	* 动态分配：提高设备利用率

### 数据结构

* 设备类表
	* 每类设备对应于设备类表的中一栏 
	* 包括：设备类，总台数，空闲台数，设备表起始地址等 
	* 支持设备独立性时才会使用
* 设备表 
	* 每类设备都有各自的设备表，用来登记这类设备中的每台物理设备 
	* 包括：物理设备名（号），逻辑设备名（号），占有设备的进程号，是否分配，好/坏标志等

## 4.9 磁盘的物理结构

* 磁道号
	* 磁面
* 柱面号
	* 磁道
* 扇区号

>  “0面0道”中的“面”是指磁头，不是柱面

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106000153976.png" alt="image-20210106000153976" style="zoom:67%;" />

### 磁盘读取

1. 寻道
2. 旋转
3. 数据传送

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106000306163.png" alt="image-20210106000306163" style="zoom:80%;" />

## 4.10 磁盘的驱动调度

### 移臂调度

目的：使移动臂的移动时间最短，从而减少寻道总时间

*详见补充*

### 旋转调度

目的：使得旋转延迟的总时间最少

* 循环排序

	* 通过优化I/O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求

* 优化分布

	![image-20210106000808180](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106000808180.png)

## 4.11 SPOOLing系统

https://www.cnblogs.com/Codroc/p/12841295.html

将**独占型设备变成共享设备**的一种技术

### SPOOLing设计

* 为存放输入数据和输出数据，系统在磁盘上开辟输入井和输出井 
	* 井是用作缓冲的存储区域

![image-20210106001029049](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106001029049.png)

* 作用 
	* 预输入：操作系统将作业需要的输入数据成批从输入设备上预先输入至磁盘的输入缓冲区中暂存 
		* 调度作业执行时，作业使用数据不必再启动输入设备， 从磁盘的输入缓冲区读入即可 
	* 缓输出：作业不启动输出设备，只是将输出数据暂 存到磁盘的输出缓冲区 
		* 作业执行完毕后，由操作系统成批输出

### 作业状态

输入井中的作业有以下四个状态：

1. 输入状态：作业信息正在从输入设备上预输入
2. 收容状态：作业预输入结束，但未被选中执行
3. 执行状态：已被选中执行，在运行过程中可以从输入井读数据，可以向输出井写数据
4. 完成状态：作业已撤离，作业的输出结果等待缓输出

![image-20210106001354679](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106001354679.png)

### 应用：打印机SPOOLing

* 打印机空占问题 
	* 如果用户进程通过打开打印机的设备文件来申请和 使用打印机，往往会造成该进程打开设备文件后长 达数小时不用，但其他进程又无法使用打印机 
* 打印机守护进程和SPOOLing打印目录 
	* 守护进程是唯一有特权使用打印机设备的进程 
	* 打印文件前，用户进程先产生完整的待输出文件，并存放在打印目录下 
	* 打印机空闲时，启动守护进程，打印待输出文件

## 4.12 批处理系统的作业管理

![image-20210106001848377](https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210106001848377.png)

## 补充

### 磁盘调度策略

* **FIFO**

	* 按顺序处理
	* 对所有进程公平

* **Priority**

	* 优先级调度
	* 这种方法并不会优化磁盘的使用率，但可以满足操作系统的其他目标
	* 通常比较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级低，这就使得大量短作业能够迅速地通过系统，并且可以提供比较好的交互响应时间，但是长作业不得不等待很长的时间

* **后先先出LIFO**

	* 在事务处理系统中，把设备资源提供给最近的用户，会导致磁头臂在一个顺序文件中移动时移动得很少，甚至不移动 
	* 利用这种局部性可以提高吞吐量，减少队列长度
	* 只要一个作业积极地使用文件系统，它就可以尽可能快地得到处理
	* 可能会饿死

* **最短服务时间优先SSTF**

	* 选择使磁头臂从当前位置**开始移动最少**的磁盘I/O请求，因此 SSTF策略总是选择导致最小寻道时间的请求
	* 总是选择最小寻道时间并不能保证平均寻道时间最小，但是，它的性能比FIFO更好

* **SCAN扫描算法**

	* 要求磁头臂仅仅沿一个方向移动，并在途中满足所有为完成的请求，直到它到达这个方向上的**最后一个磁道**
	* 接着反转服务方向，沿着相反方向扫描，同样按顺序完成所有请求

* **LOOK电梯调度算法**

	* 要求磁头臂仅仅沿一个方向移动，并在途中满足所有为完成的请求，直到它到达这个方向上的**没有其他请求为止**
	* 接着反转服务方向，沿着相反方向扫描，同样按顺序完成所有请求

* **C-SCAN 循环扫描**

	* 把扫描限定在一个方向
	* 当访问到沿某个方向的最后一个磁道时，磁头臂返回到磁盘相反方向磁道的末端，并再次开始扫描

* **N-step-SCAN**

	* 把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列 
	* 在处理一个队列时，新请求必须添加到其他某个队列中
	* 如果在扫描的最后剩下的请求数小于N，则它们全部将在下一次扫描时处理 

* **FSCAN**

	* 使用两个子队列
	* 当开始扫描时，所有请求都在一个队列中，而另一个队列为空,在扫描过程中，所有新到的请求都被放入另一个队列中
	* 因此，对新请求的服务延迟到处理完成所有老请求之后

* **C-LOOK**

	<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/image-20210108230642284.png" alt="image-20210108230642284" style="zoom:67%;" />