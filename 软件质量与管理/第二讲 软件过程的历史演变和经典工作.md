# 第二讲 软件过程的历史演变和经典工作

## 软件开发的本质难题

* 不可见性
  * 例如：很多时候探讨软件系统是基于别人的理解来进行的，因此很容易出错
  * 最本质的本质难题，软件工程方法很难解决，另外三个会因不同项目而有差异
* 复杂性
  * 特别是现在微服务环境下更加复杂（微服务的交互，微服务生态等）
* 可变性
  * 需求变更等
* 一致性
  * 除了兼容，还有其他方面问题

分析：

1. 三个本质难题因项目而异
2. 四大本质难题相互促进
3. 本质难题的变化带动软件方法（过程）的演变
4. 软件过程的发展，其驱动力就来源于四大本质难题的变化

## 软件发展三大阶段

### 软硬件一体化阶段（50年代～70年代）

**软件完全依附于硬件**

> \- 软件之所以有存在的价值，是为了支持硬件完成计算任务，通过软件能够让硬件计算任务顺畅做下去，但是没有软件这些硬件可能一样能完成任务（尽管比较曲折）。这种软件功能自然就很单一，复杂度也就极其有限，同样也基本不会出现需求变更。
>
> \- 数学家、硬件工程师这些人既是开发者，往往也是最终的使用者
>
> \- 硬件贵到什么程度？IBM预测全球只需要4个小型机就足够。当时的电脑就是租用的，租金时计是付给软件工程师时薪的数量级倍数
>
> \- 在这种背景之下，软件开发过程中几乎所有阶段都有规格说明（一种非常严格的定义），因为需求非常固定有限

- 软件应用典型特征

  - 软件支持硬件完成计算任务

  - 功能单一

  - 复杂度有限

  - 几乎不需要需求变更

- 软件开发典型特征

  - 硬件太贵——在某些情况下用人力去取代计算机（比如调试

  - 团队以硬件工程师和数学家为主

* 典型软件过程
  * 线性开发
* 典型软件实践
  * Measure twice，cut once
  * “Measure”就是手动验证程序的正确性，现代软件工程中，code review就和这种实践比较类似（通过人工阅读代码来消除错误）

**软件作坊**

> 应用特征没有太大变化，功能更多类似于电子表格类开发，规模亦不会太大
>
> \- 功能点在这个时代出现：有几个输入，有几个输出
>
> 非专业领域人员涌入
>
> \- 因为高级程序语言的出现降低了开发的难度
>
> \- 同时还有个人英雄主义的出现带来质疑权威的文化
>
> \- 进而带来一种实践：code and fix

- 软件应用典型特征

  - 功能简单

  - 规模小

- 软件开发典型特征

  - 很多非专业领域的人员涌入软件开发领域

  - 高级程序设计语言出现——贴近自然语言，降低了学习成本

  - 质疑权威文化开始流行——崇尚个人英雄主义

- 典型软件过程和实践

  - code and fix
  - 非常糟糕的实践，只适用于功能简单，规模小，不适合大型软件项目开发（操作系统的开发
  - 但是那个时代的最佳实践，说明讨论好坏需要结合历史背景来辩证看待

### 软件成为独立的产品（70年代~90年代）

> \- 最重要的事情：摆脱硬件束缚（因为出现了OS对底层硬件抽象）
>
> \- 软件本质上是逻辑实体，描述人们业务逻辑和操作流程。在摆脱束缚后就可以考虑如何用软件来描述现实世界的工作流程，从而打开了广阔的想象空间，然后带来软件功能的强大，伴随而来的就是规模复杂度的剧增
>
> \- 另外一个标志性事件：个人电脑的出现。因为它使得普通人成为软件用户，用户数量的激增带来需求的多变和对兼容性的要求
>
>  \- 这个时候需求调研可能已经不重要的，而更需要一个强有力的产品经理，让他提出一个需求并说服用户 —— 规格化
>
>  \- 软件成为独立产品也使得很多公司可以以软件作为主要业务来生存，这也就意味着同样的功能不同的公司都可以做 —— 市场竞争压力，其中最突出的可能是数据库（几十个不同的数据库管理系统）

* 软件应用典型特征

  * 摆脱了硬件束缚——>原因：操作系统的出现

  * 功能强大

  * 规模和复杂度剧增

  * 个人电脑出现——>普通人成为软件用户

    - 需求多变

    - 兼容性要求

  * 来自市场的压力

* 典型软件过程和实践

  * 方法之一：**形式化方法**

    * 用数学手段来保障软件质量，有很高的使用的壁垒

  * 方法之二：**结构化程序设计和瀑布模型**

    * <img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211223223420815.png" alt="image-20211223223420815" style="zoom: 67%;" />

    * 左边才是真正的瀑布模型，支持往回

    * 右侧的模型虽然不对，但是可以帮助传递知识

    * Lean development

      - 该书作者说瀑布模型的本意是：这个模型不适合软件系统开发

      - 但是，Royce本人是支持生命周期模型的

    * Royce对软件生命周期模型的理解

      - 软件生命周期是一个系列

      - 软件项目团队在考虑生命周期模型的时候，要考虑上下文

      - 大部分项目团队过度轻视了项目的复杂度和挑战，选择了不适合的生命周期模型

    * 问题和不足

      - 形式化在扩展性和可用性方面存在不足

      - 瀑布模型成为一个重文档、慢节奏的过程

  * **成熟度模型（CMM、CMMI、Capability Maturity Model Integration**

    * <img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211223223609282.png" alt="image-20211223223609282" style="zoom:67%;" />

      

### 网络化和服务化（90年代中期迄今）

* 软件应用特征

  * 需求更复杂，规模更大
  * 用户数量急剧增加（导致传统需求开发方法不适用
  * 快速演化和需求不确定
  * 分发方式的变化——SAAS（阿里、google每天更新5k次，但是用户很难感知到

* 典型软件过程和实践

  * **迭代式**

    * 定义：大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。
    * 所谓逐步学习和交流：迭代式的前半句让甲乙双方第一次平等了，这也是为什么敏捷方法强调客户的合作，即甲乙双方共同决定系统演化的方向
    * 软件开发：乙方地位越高，产品效果往往越好，这也是为什么像微信这样的程序能够成为爆品

  * **雪鸟会议和敏捷宣言**

    * 层次：<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211224143524411.png" alt="image-20211224143524411" style="zoom:50%;" />

    * 四个核心价值（前提：右项同样有价值，但是更重视左边的价值）

      - 个体和互动 胜过 流程和工具

      - 可以工作的软件 胜过 详尽的文档

      - 客户合作 胜过 合同谈判

      - 响应变化 胜过 遵循计划

    * 一些敏捷方法（并不都是好处）

      * XP（extreme programming）极限编程
        * 偏重于一些工程实践的描述（3C项目
        * 技术实践的集合，没有管理过程、框架（这种说法是不对的！
      * SCRUM
        * 管理框架和管理实践
        * 简单、便于传播
        * burndown（燃尽图
        * 站立式会议
        * 现在提到敏捷方法，第一个指向的是SCRUM
      * Kanban
        * 精益生产的具体实现（一步一步相互关联
        * 可视化工作流、限定WIP、管理周期时间
        * 项目公开，便于交流
        * 需要保持流水线的运行，否则会导致工作的停滞
      * RUP
        * 一系列方法

  * **开源软件开发方法**

    * 一种基于并行开发模式的软件开发的组织与管理方式

      ![image-20211224144511687](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211224144511687.png)

      - 前提：足够的用户

      - 个人英雄主义不再出现

    * 代码管理

      - 严格的代码提交社区审核制度

      - 配置管理

      - pull request

    * 演化

      - 内部开源（inner source

        - 在组织内部进行开源

        - 产品线的定制化开发

        - 解决效率问题，而不是质量问题

      - 众包（crowdsourcing

        - 解决资源问题

        - 将任务作为包，然后分发下去

        - 有一个管理团队，这个团队/拥有者来完成功能设计和未来走向
        - 涉及到奖励

### 当前软件发展现状

* 软件应用的典型特征
  * 进一步服务化和网络化（移动是主流）
  * 用户需求多样性进一步凸显
  * 软件产品和服务的地位变化（从属关系 --> 对等关系 --> 软件处于掌控地位（对软件出错容忍度几乎为0））
  * 错综复杂的部署环境（成千上万微服务同时运行，相互协调，甚至竞争计算资源）
  * 进步苛刻的用户期望
    * 多：功能丰富、个性化
    * 快：快速使用、及时更新、快速解决问题
    * 好：稳定、可靠、安全、可信
    * 省：用户获得成本低、最好免费（  反摩尔定律：若每隔一年半才能将新功能推出给用户，获取的收益会显著下降）
  * 空前强大的开发和部署环境（XAAS、IAAS、PAAS、FAAS，盛行共享和开源）
  * 潜在支撑获得了长足进步（AI、大数据、云计算等）
* 典型DevOps实践和方法
  * 方法论基础是敏捷软件开发、精益思想以及看板Kanban方法（开始追求DevOps成熟度模型）
  * 以领域驱动设计为指导的微服务架构方式
    * 希望在不影响其它服务的情况下实现高频服务更新
  * 大量虚拟化技术的使用
    * 使得开发测试环境和生产环境可以做到几乎一样
    * 方便在开发环境中进行问题的排查
  * 一切皆服务XaaS的理念指导
  * 构建了强大的工具链，支持高水平自动化
    * 围绕DevOps的工具从50个发展到1000多个

## CMM/CMMI

> 体现一个公司/组织在实现自己的商业目标上的能力

<img src="https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211223223609282.png" alt="image-20211223223609282" style="zoom:67%;" />

- 出现原因

  - 80年代中期，软件产业蓬勃发展，美国军方为了区分公司的能力

  - 根据chaos report，很多项目都失败了——大部分承接软件开发的公司不具备能力

  - 不是一个特定的软件过程

- 五个级别

  - Initial 原始级别，开发相对混乱，依赖个人英雄主义，没有过程概念，救火文化盛行；

  - Managed 已经管理级别，项目小组级体现着项目管理的特征，有项目计划和跟踪，需求管理、配置管理等等；

    - 为了促成知识经验共享，升级到三级

    - 有目标定义、状态管理、纠偏跟踪（项目级

  - Defined，已经定义级别，在公司层有标准流程和相应的裁剪规范，每个项目小组可以据此定义自己的过程，使得优秀的做法可以在公司层共享；（好处：避免糟糕的实践，能够迅速落地，可以根据项目进行裁剪，促成知识和经验的共享）

    - 组织级

    - 为了能够让经验教训可以在组织内快速传播

    - 束缚创造力

    - 用模版方法可以很好的解决

  - Quantitatively Managed, 定量管理，构建预测模型，以统计过程控制的手段来管理过程项目；关注：怎样让预测出的结果尽可能可靠，消除过程的偶然因素——相对的必然因素：

    - 偶然因素：random——随机原因

    - 偏差管理
      - 上面的三个等级，如果产生了项目进度的落后，会赶进度；而第四级则会根据历史经验（模型）比对进行进度的调整

  - Optimizing 持续优化，继续应用统计方法识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题。

- ✨高低成熟度认定偏差的方式不一样

  - 低级成熟度：基于已经发生的事实

  - 高级成熟度：根据模型预测最终结果，进行比对识别偏差

- DevOps认为CMMI是一种测试，这是一种误解

- 讨论

  - CMMI是过程改进模型而非软件过程或者软件过程模型 ☑️
    - 不是软件过程，没有开发的过程

  - CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较 ☑️
    - CMMI的前提：当前的过程能力和业务需求不匹配
    - 初创公司可以直接就达到Level5，而有的大公司（Google）可能还处于Level1
    - 不论CMM还是CMMI，其等级仅体现它在实现自己的商业目标上的能力，也就是如果两个公司的商业目标相同，那么它们之间的能力就可以通过CMMI模型来比较

  - CMMI VS. Agile是一个伪命题❎
    - CMMI模型本身并不是开发模型，而是一个过程改进的模型，刻画了软件组织从不成熟到成熟的路线图，简单说，CMMI模型不是一种具体的开发方法。而大部分所谓的敏捷方法都是开发方法，因此，两者是完全不同性质的事物，将这两者对立是不合适的。