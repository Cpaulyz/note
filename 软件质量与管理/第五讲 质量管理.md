# 第五讲 质量管理

软件项目的成本、质量、工期三大目标统一于质量目标。

## 软件质量概念

与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体”

## 面向用户的质量观

### 定义

PSP中也采用了面向用户的视图，定义质量**为满足用户需求的程度**。

在这个定义中，就需要进一步明确：

* 用户究竟是谁？
* 用户需求的优先级是什么？
* 这种用户的优先级对软件产品的开发过程产生什么样的影响？
* 怎样来度量这种质量观下的质量水平？

### PSP质量策略

* 用缺陷管理来替代质量管理

  > 几乎在任何一个列表中，用户都会把软件产品能够工作作为一个最基本的期望。
  >
  > 事实上，如果软件产品本身不能工作，那么考虑其他的期望是没有意义的。而为了使一个软件产品可以工作，该产品基本没有缺陷是最基本的要求。这样一来，整个软件产品的质量目标就可以归结成首先得确保基本没有缺陷，然后再考察其他的质量目标。PSP中就采用了这样的方式，用缺陷管理来替代质量管理，这大大简化了质量管理的方法，使得质量管理更加易于操作。

* 高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷

* 各个组件的高质量是通过高质量评审来实现的

  > 在测试阶段消除缺陷的效率远比评审阶段消除缺陷的效率要低。
  >
  > 测试消除缺陷：
  >
  > 1. 发现待测程序的一个异常行为；
  > 2. 理解程序的工作方式；
  > 3. 调试程序，找出出错的位置，确定出错原因；（往往需要数天甚至是数周）
  > 4. 确定修改方案，修改缺陷；
  > 5. 回归测试，以确认修改有效
  >
  > 评审消除缺陷（每一步消耗的时间都不会太多。尽管评审的技能因人而异，但是，通过适当培训和积累，有经验的评审者可以发现80%左右的缺陷。）：
  >
  > 1. 遵循评审者的逻辑来理解程序流程；
  > 2. 发现缺陷的同时，也知道了缺陷的位置和原因；
  > 3. 修正缺陷；

### PSP评审过程质量

* **评审检查表**

  * 大部分人不知道怎么进行评审
  * 最好的来源——缺陷日志——根本原因栏目中的内容

* **评审控制指标**

  * **Yield**

    ![image-20211225145255501](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211225145255501.png)

    ![image-20211225145311610](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211225145311610.png)

    * 度量每个阶段在消除缺陷方面的效率
    * Phase Yield = 100 * （某阶段发现/解决的个数）/（某阶段注入的 + 进入该阶段前遗留的）
    * Process Yield = 100 * （第一次编译发现/解决的错误）/（第一次编译前注入的个数）
    * 问题：
      * 缺陷是否消除完全是不可知的
      * 具体的数量是不可知的
    * 解决方法：
      * 假设单元测试阶段的phase yield为50（测试中没发现一个缺陷，往往有一个缺陷未被发现）
      * 按比例增加各个阶段注入的缺陷（3-4 ⇨ 3-5）

  * **A/FR**

    * A/FR = PSP质检成本 / PSP失效成本
    * PSP中定义的质检成本为设计评审时间与代码评审时间之和
    * PSP中定义的失效成本为编译时间和单元测试时间之和
    * 控制目标：
      * 理论上，A/FR的值越大，往往意味着越高的质量。
      * 但过高的A/FR往往意味着做了过多的评审，反而会导致开发效率的下降。
      * 期望值就是2.0

  * **PQI（process quality index 过程质量指标）**

    * 作用

      * 度量PSP过程的整体指标

        > 软件组件的质量由开发过程的质量决定。Yield、A/FR无法充足刻画过程的质量

    * 五个数据的乘积

      * 设计质量：设计的时间应该大于编码的时间
        - `Min{ 设计时间 / 编码时间, 1}`
      * 设计评审质量：设计评审的时间应该大于设计时间的50%
        - `Min{ 设计评审时间*2 / 设计实践, 1}`
      * 代码评审质量：代码评审时间应该大于编码时间的50%
        - `Min{ 代码评审时间*2 / 编码时间, 1}`
      * 代码质量：代码的编译缺陷密度应当小于10个/千行
        - `Min{ 20 / (实际编译的缺陷密度 + 10), 1}`
      * 程序质量：代码单元测试缺陷密度应当小于5个/千行
        - `Min{ 10 / (时间单元测试的缺陷密度+5), 1}`

    * PQI越高，交付后缺陷越少；PQI越高，集成测试时缺陷越少。

  * **Review Rate**

    * 指导软件工程师开展有效评审的指标
    * 代码评审速度小于200 LOC/小时，文档评审速度小于4 Page/小时
    * 如果不计成本的投入大量时间进行评审，尽管可能发现较多的缺陷，但是又会影响到整个软件过程的生产效率。因此，应当为评审设置一个恰当的速度。

  * **DRL（Defect-Remove Leverage，缺陷消除效率比）**

    * 度量的是不同缺陷消除手段消除缺陷的效率
    * 其他阶段（度量阶段）每小时发现的缺陷数 / 某个测试阶段每小时发现的缺陷数（一般是UT）
    * 一般情况下，审计评审阶段发现缺陷的效率和单元测试相当，代码评审发现缺陷的效率远远高于单元测试

* 其他因素

  * **环境**

    * 打印后评审效果更好
    * 单个屏幕可以展现的内容比较有限

  * **评审时机**

    * 先做个人评审再做单元测试

      - 单元测试消除测试的能力是一定的，要有提高就要做评审

      - 单元测试之后再做评审可能会影响个人评审的细致

      - 在评审上花的时间是一样的
        - 但是态度可能是不一样的

  * **个人评审和小组评审**

    * 小组评审是对别人资源的使用，要对别人有足够尊重
    * 先后顺序

  * **缺陷预防**

    * 缺陷原因的分类、分析
    * 8 2 法则

### 质量路径

- 追求高质量的手段

  - Step1:各种测试

  - Step2:进入测试之前的产物质量提升——评审inspection

  - Step3:评审过程度量和稳定

  - Step4:质量意识和主人翁态度——review

  - Step5:个体review的度量和稳定
    - 到此为常规手段

  - Step6:诉诸设计
    - 对当前项目的终极手段

  - Step7:缺陷预防
    - 对未来的开发

  - Step8:用户质量观——其他质量属性

## 设计与质量的关系

* 低劣的设计是导致在软件开发中返工、不易维护以及用户不满的主要原因。
* 充分设计可以显著减少最终程序的规模，提升质量。
* 设计本身也是一种排错的过程。

## PSP设计

### 设计过程

![image-20211225151500640](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211225151500640.png)

### 设计内容

* 设计目标程序在整个应用系统中的位置；
* 设计目标程序的使用方式；
* 设计目标程序与其他组件以及模块之间的关系；
* 设计目标程序外部可见的变量和方法；
* 设计目标程序内部运作机制；
* 设计目标程序内部静态逻辑；

### 设计模板

|          | 动态信息 | 静态信息 |
| -------- | -------- | -------- |
| 外部信息 | OST、FST | FST      |
| 内部信息 | SST      | LST      |

* **OST（Operational Specification Template， 操作规格模板）**
  * 系统与外界的交互，用来定义测试场景和测试用例，也可以作为和系统用户讨论操作相关需求的基础
* **FST（Functional Specification Template，功能规格模板）**
  * 系统对外的接口，提供的典型信息包括类和继承关系，外部可见的属性和外部可见的方法等。
  * 消除二义性非常重要，如果有可能，尽可能用形式化符号来描述方法等行为
* **SST（State Specification Template，状态规格模板）**
  * 精确定义程序的所有的状态、状态之间的转换以及伴随着每次状态转换的动作
  * 软件设计人员可以定义状态机结构，分析状态机设计结果，从而消除设计中引入的逻辑缺陷。
* **LST（Logical Specification Template，逻辑规格模板）**
  * 精确描述系统的内部静态逻辑，比如关键方法的静态逻辑、方法的调用、外部引用、关键数据类型和定义等。
  * 为了消除描述的二义性，一般建议用伪代码配合形式化符号来描述设计结果

### UML与PSP设计模板的关系

UML常用图有：用例图、时序图、类图、状态机图

1. 用例图、时序图 ➡ 提供了OST相同的信息
2. 时序图、类图描述的类之间的关系和对象之间的交互信息  ➡ 在PSP设计模板中没有对应内容
3. 类图记录了方法的型构，方法的行为没有描述  ➡ 在FST中有相应的内容
4. 状态图  ➡ SST，但是SST中描述的关于状态、状态转换条件以及状态转换中的动作没有对应的UML图示方法
5. LST用以描述程序的静态逻辑，这在UML没有对应的图示方法

### 设计验证方法

意义：简单评审不足以发现复杂缺陷

> 提高设计评审和代码评审阶段的yield十分重要。
>
> 对于代码评审，控制评审速度、使用检查表等手段十分有效；
>
> 对于设计评审，需要更多的手段来检查譬如“程序逻辑是否正确“等检查项。

* **状态机验证**

  * 正确条件：
    * 完整（所有的状态组合都考虑到，从某一个状态出发的所有转换条件和组合都考虑在内）
    * 正交（相同状态且相同条件的下一个状态一定是相同且唯一的状态）
  * 验证方式（参考教材看）：
    * 检验状态机，消除死循环和陷阱状态。
    * 检查状态转换，验证完整性和正交性。
      * 使用真值表
    * 评价状态机，检验是否体现设计意图

* **符号化执行验证**

  * ![image-20211225160253411](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211225160253411.png)

  * 基本思想是将描述设计的逻辑规格（一般用伪代码程序表示）用代数符号来表示，然后系统地开展分析和验证，步骤如下：

    * 识别伪码程序中的关键变量；
    * 将这些变量用代数符号表示，重写伪码程序；
    * 分析伪码程序的行为。

  * 只是帮助理解程序行为，不能直接判断是否正确

  * 优缺点

    - 实施简单，往往是唯一提供全面验证的方式

    - 通常用在复杂算法中，识别和理解原有设计

    - 不适用于有复杂逻辑的场合

* **执行表验证**

  * ![image-20211225160439023](https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211225160439023.png)
  * 用有序的方法来跟踪伪码程序的执行状况，分析程序行为，验证设计，具体步骤如下：
    * 识别伪码程序的关键变量；
    * 构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；
    * 初始化被选定的变量；
    * 跟踪被选择的关键变量的变化情况，从而判断程序行为。
  * 手工验证方式，耗时、容易出错

* **跟踪表验证**

  * 是执行表的一种扩充

    * 识别伪码程序的关键变量；
    * 构建表格，表格左侧填入主要程序步骤，右侧填入关键变量；
    * 初始化被选定的变量；
    * *识别将伪码程序符号化的机会，并加以符号化*

    - *定义并且优化用例组合*

    * 跟踪被选择的关键变量的变化情况，从而判断程序行为。

* **正确性验证**

  * 伪码程序当成数学定理，采用形式化方法加以推理和验证。